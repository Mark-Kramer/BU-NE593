[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BU NE593 (Spring 2026)",
    "section": "",
    "text": "Introduction\n\nRead the syllabus\nRead: Buzsaki and Draguhn, Neuronal Oscillations in Cortical Networks, Science, 2004\nRead: Riquelme and Gjorgjieva, Towards readable code in neuroscience, Nat Rev Neuro, 2021\nRead: Wing, Computational Thinking, Comm ACM, 2006\nRead: Chapter 4 (Intro to Programming) @ Cohen, Analyzing Neural Time Series Data, 2014\nRead: Chapter 37 (Themes & Advice) @ Cohen, Analyzing Neural Time Series Data, 2014\nLecture Slides: Rhythms, Programming Habits\nCode: Intro to Python"
  },
  {
    "objectID": "Perceptron.html",
    "href": "Perceptron.html",
    "title": "Perceptron",
    "section": "",
    "text": "In this notebook, we will construct simple perceptron models. We’ll start by implementing a perceptron model, and seeing how it behaves. We’ll then outline the steps to train a perceptron to classify a point as above or below a line.\nThis discussion follows the excellent example and discussion at The Nature of Code. Please see that reference for additional details, and a more sophisticated coding strategy (using Classes in Python)."
  },
  {
    "objectID": "Perceptron.html#provide-perceptron-with-inputs-and-known-answer.",
    "href": "Perceptron.html#provide-perceptron-with-inputs-and-known-answer.",
    "title": "Perceptron",
    "section": "3.1 Provide perceptron with inputs and known answer.",
    "text": "3.1 Provide perceptron with inputs and known answer.\nFirst, let’s make a function that computes a line, and determines if a given y value is above or below the line. We’ll use this function to return the correct (“known”) answer. Having known answers is important for training the perceptron. We’ll use the known answers to tell the when it’s right or wrong (i.e., when the perceptron makes an error).\nLet’s define the function (known_answer) should take four inputs:\n\nslope\nintercept\nx\ny\n\nwhere the (x,y) value is a point we choose on the plane. The function should return one output:\n\ndesired_output\n\nwhere,\ndesired_output = 1, if the y value (the last input) is above the line,\ndesired_putput = 0, if the y value (the last input) is below the line.\nComplete the function below:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Consider the (x,y) point,\n\n\nx,y = 0.7,3\n\n\nand the line with slope and intercept,\n\n\nslope = 2  intercept = 1\n\n\nIs the (x,y) point above or below the line?\n\n\n\nA: To answer this, let’s ask our function,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nA (Continued): We find a correct_answer of 1.\n\n\nSo, the point (x,y)=(0.7,3) is above the line with slope 2 and intercept 1."
  },
  {
    "objectID": "Perceptron.html#ask-perceptron-to-guess-an-answer.",
    "href": "Perceptron.html#ask-perceptron-to-guess-an-answer.",
    "title": "Perceptron",
    "section": "3.2 Ask perceptron to guess an answer.",
    "text": "3.2 Ask perceptron to guess an answer.\nOur next step is to compare our desired output (computed in Step 1) to the output guessed by the perceptron. To do so, we’ll need to compute the feedforward solution for the perceptron (i.e., given the inputs and bias, determine the perceptron output). Let’s do so complete the function below,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis function takes five inputs:\n\nx = the x coordinate of the point we choose in the plane.\ny = the y coordinate of the point we choose in the plane.\nwx = the weight of x input.\nwy = the weight of y input.\nwb = the weight of the bias.\n\nAnd this function returns one output:\n\nthe perceptron’s guess, is the point above (=1) or below (=0) the line.\n\n\n\n\n\n\n\nQ: Again consider the (x,y) point,\n\n\nx,y = 0.7,3\n\n\nand set initial values for the perceptron weights. Let’s just set these all to 0.5; our goal in the rest of this module will be to train the perceptron by adjusting these weights. But for now,\n\n\nwx,wy,wb = 0.5\n\n\nThen, ask the perceptron for it’s guess for it’s guess, is the point above or below the line?\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nA: We find a peceptron_guess of 1.\nSo, the perceptron guesses that the point (x,y)=(0.7,3) is above the line."
  },
  {
    "objectID": "Perceptron.html#compute-the-error.",
    "href": "Perceptron.html#compute-the-error.",
    "title": "Perceptron",
    "section": "3.3 Compute the error.",
    "text": "3.3 Compute the error.\nWe’ve now answered the question “Is the (x,y) point above the line?” in two ways:\n\nthe known answer, and\nthe perceptron’s guess.\n\nLet’s compute the error as the difference between these two answers:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What do you find for the error? Does it make sense?"
  },
  {
    "objectID": "Perceptron.html#adjust-all-weights-according-to-the-error.",
    "href": "Perceptron.html#adjust-all-weights-according-to-the-error.",
    "title": "Perceptron",
    "section": "3.4 Adjust all weights according to the error.",
    "text": "3.4 Adjust all weights according to the error.\nTo update the weights, we’ll use the expression,\nnew weight = weight + error * input * learning constant\nWe need to compute this for each weight (wx, wy, wb).\nFirst, let’s set the learning constant,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThen, we can compute the new weights,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNotice that, in the update to wb we use the fact that the bias equals 1.\n\n\n\n\n\n\nQ: What do you find for the new weights? Does it make sense?"
  },
  {
    "objectID": "Perceptron.html#return-to-step-1-and-repeat",
    "href": "Perceptron.html#return-to-step-1-and-repeat",
    "title": "Perceptron",
    "section": "3.5 Return to Step 1 and repeat …",
    "text": "3.5 Return to Step 1 and repeat …\nWe could try to compute these repetitions by hand, for example by repeating the cells above. To do so, we’d choose a new point in the (x,y) plane, determine whether it’s above the line 2x+1, ask the perceptron to guess whether it’s above the line, then use the error to update the perceptron’s weights.\nBut we want to evaluate this procedure 2000 times. Doing so by hand would be a total pain, and highly error prone. Instead, let’s ask the computer to do the boring work of multiple repetitions. To do so, let’s collect the code above, and examine 2000 (x,y) points chosen randomly in the plane. We’ll wrap our code above inside a for-loop to make this efficient,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  },
  {
    "objectID": "LIF.html",
    "href": "LIF.html",
    "title": "Leaky Integrate and Fire Neuron",
    "section": "",
    "text": "In this notebook we will use Python to simulate the leaky integrate and fire (LIF) neuron model. We’ll investigate, in particular, how the spiking activity varies as we adjust the input current \\(I\\).\n\n1 Preliminaries\nBefore beginning, let’s load in the Python package we’ll need:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n2 Numerical solutions - Introduction\nHow do we compute a numerical solution to the integrate and fire model? The basic idea is to rearrange the differential equation to get \\(V(t+1)\\) on the left hand side, and \\(V(t)\\) on the right hand side. Then, if we know what’s happening at time \\(t\\), we can solve for what’s happening at time \\(t+1\\).\nFor example, consider the differential equation:\n\\[\n  \\dfrac{dV}{dt} = -\\dfrac{V-V_*}{\\tau}\n\\]\nIn words, we can think of:\n\\(dV\\) as the “change in voltage V”,\n\\(dt\\) as the “change in time t”.\nLet’s consider the case that we record the voltage \\(V\\) in discrete time steps. So we observe:\n\\(V[0], V[1], V[2], \\ldots\\)\nat times:\n\\(dt, \\, 2*dt, \\, 3*dt, \\ldots\\)\nwhere \\(dt\\) is the time between our samples of \\(V\\).\nWe can now write the “change in voltage V” as:\n\\[\n  dV = V(t+1) - V(t)\n\\]\nNotice that the change in voltage is the difference in V between two sequential time samples. Now, let’s rewrite \\(\\dfrac{dV}{dt}\\) as,\n\\[\n  \\dfrac{dV}{dt} = \\dfrac{ V(t+1) - V(t) }{ dt }\n\\]\nwhere we’ve replaced \\(dV\\). Now, let’s substitute this expression into the equation at the top of this file:\n\\[\n  \\dfrac{ V(t+1) - V(t) }{ dt } = \\dfrac{I}{C}.  \n\\]\nSolving this equation for \\(V(t+1)\\) you’ll find that:\n\\[\n  V(t+1) = V(t) + dt*(-\\dfrac{V(t)-V_*}{\\tau})\n\\]\nNotice that, in this expression, we use our current value of the voltage \\(V(t)\\) and the model (\\(-\\dfrac{V(t)-V_*}{\\tau}\\)) to determine the next value of the voltage V(t+1).\nNow, let’s program this equation in Python. First, let’s set the values for the parameters \\(V_*\\) and \\(\\tau\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe also need to set the value for \\(dt\\). This defines the time step for our model. We must choose it small enough so that we don’t miss anything interesting. We’ll choose:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLet’s assume the units of time are seconds. So, we step forward in time by \\(0.01\\) s.\nThe right hand side of our equation is nearly defined, but we’re still missing one thing, \\(V(t)\\).\n\n\n\n\n\n\nQ: What value do we assign to \\(V(t)\\)?\n\n\n\nSo here’s an easier question: what initial value do we assign to \\(V(t)\\)?\nTo start, we’ll create an array of zeros to hold our results for \\(V\\):\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis array V consists of 1000 rows and 1 column. We can think of each row entry as corresponding to a discrete step in time. Our goal is to fill-in the values of V (i.e., step forward in time), in a way consistent with our model.\nLet’s choose an initial value for V of 0.2, which in our simple model we’ll assume represents the rest state.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Given the initial state V[0]=0.2, calculate V[1]. Then calcualte V[2].\n\n\n\nAfter the two calculations above, we’ve moved forward two time steps into the future, from \\(t=0\\) s to \\(t=0.01\\) s, and then from \\(t=0.01\\) s to \\(t=0.02\\) s. But what if we want to know \\(V\\) at \\(t=10\\) s? Then, this iteration-by-hand procedure becomes much too boring and error-prone. So, what do we do? Let’s make the computer do it …\n\n\n3 Numerical solutions - Implementation\nLet’s computerize this iteration-by-hand procedure to find V[999].\nTo do so, we’ll use a for-loop.\nHere’s what it looks like:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Does this loop make sense? Describe what’s happening here. What is something?\n\n\n\n\n\n\n\n\n\nQ: Why does the range command end at 999?\n\n\n\nExecute this for-loop and examine the results in vector V. To do so, let’s plot V:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What happens to the voltage after 1000 steps?\n\n\n\nThis plot is informative, but not great. Really, we’d like to plot the voltage as a function of time, not steps or indices. To do so, we need to define a time axis:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What’s happening in the command above? Does it make sense? (If not, trying printing or plotting t.)\n\n\n\nNow, with time defined, let’s redo the plot of the voltage with the axes labeled appropriately.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nFinally, let’s put it all together . . .\n\n\n4 LIF CODE (version 1)\nSo far, we constructed parts of the I&F model in bits-and-pieces. Let’s now collect all the code, compute a numerical solution to the I&F model, and plot the results (with appropriate axes).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Adjust the parameter Vstar. What happens to V if Vstar=0? Can you set Vstar so that V &gt; 20 within 10 s?\n\n\n\n\n\n5 Voltage threshold & reset\nNotice, our model is missing something important: the reset.\n\n\n\n\n\n\nQ: Without the reset, how does the voltage behave as \\(t\\rightarrow\\infty\\) (if \\(Vstar&gt;0\\))?\n\n\n\nNow, let’s update our model to include the reset. To do so, we’ll add two things to our code.\n\nFirst, we’ll define the voltage threshold Vth, and reset voltage Vreset.\nSecond, we’ll check to see if V exceeds Vth using an if-statement; if it does, then we’ll set V equal to Vreset.\n\n\n\n\n\n\n\nQ: How will you update the code below to include the reset?\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n6 I&F CODE (version 2)\nNow, let’s put it all together to make a complete I&F model (with a thershold and reset), simulate it, and plot the result.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Adjust the parameter I. What happens to V if I=10? If I=100?\n\n\n\n\n\n\n\n\n\nQ: Adjust the parameter C. What happens to V if C=0.1? If C=10?\n\n\n\n\n\n\n\n\n\nQ: What is “spiking” in this I&F model?\n\n\n\n\n\n\n7 Discussion\n\nDescribe the main components of the IF model. Draw it (in some way).\nDescribe the main components of the LIF model. Draw it (in some way).\nDescribe the differences and similarities between the IF and LIF models.\nThe IF model is meant to mimic a neurons activity. What is realistic about the IF model? What is unrealistic?\nDescribe the roles of the IF model parameters Vreset and Vthreshold.\nConsider the IF model. Sketch voltage (V) versus time (t) for a small input current, for a large input current.\n\nHow does an increase in capacitance (C) impact the dynamics?\nCan you interpret this physically?\n\nPlot the f-I curve for the IF model."
  },
  {
    "objectID": "HH.html",
    "href": "HH.html",
    "title": "Hodgkin-Huxley Neuron",
    "section": "",
    "text": "In this notebook we will use Python to simulate the Hodgkin-Huxley (HH) neuron model. This model is arguably the most important computational model in neuroscience. We’ll focus here on simulating this model and understanding its pieces.\n\n1 Preliminaries\nBefore beginning, let’s load in the Python packages we’ll need:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn addition, let’s import the functions we’ll need to simulate the HH model, which are available on this repository:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n2 The Hodgkin-Huxley (HH) equation code.\nTo start, let’s examine the code for the HH model. To do so, visit the raw code avaiable here.\n\n\n\n\n\n\nQ: Examine this code. Can you make sense of it? Can you identify the gating variables? The rate functions? The equations that define the dynamics? We’ll answer these questions in this in notebook, but try so on your own first.\n\n\n\nWhenever examining code, it’s useful to consider the inputs to the code, and the outputs produced by the code. There are two inputs to HH0:\n\nI0 = the current we inject to the neuron.\nT0 = the total time of the simulation in [ms].\n\nAnd there are five outputs:\n\nV = the voltage of neuron.\nm = activation variable for Na-current.\nh = inactivation variable for Na-current.\nn = activation variable for K-current.\nt = the time axis of the simulation (useful for plotting).\n\n\n\n3 At low input current (I0), examine the HH dynamics.\nTo understand how the HH model works, we’ll start by focusing on the case when I0 is small. Let’s fix the input current to zero,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nand let’s simulate the model for 100 ms,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe’ve now defined both inputs to the HH function, and can execute it, as follows,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNotice that the function returns five outputs, which we assign to the variables V, m, h, n, and t.\n\n\n\n\n\n\nQ: What are the dynamics of the voltage (variable V) resulting from this simulation? HINT: Plot V vs t.\n\n\n\n\n\n\n\n\n\nQ: What are the dynamics of the gating variables (m, h, n) resulting from this simulation? HINT: Plot them!\n\n\n\n\n\n\n\n\n\nQ: What are the final values (after the 100 ms of simulation) of V, m, h, and n?\n\n\n\n\n\n4 At high input current (I0), examine the HH dynamics of a spike.\nLet’s now increase the input current to the HH model and get this model to generate repeated spiking activity. To do so, let’s set,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe can now simulate this model,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What happens to the dynamics? HINT: Plot V vs t.\n\n\n\nObservations: You should have found that, at this value of input current, the model generates repeated spikes.\n\nLet’s now explore how the combined gates and dynamics evolve. To do so, let’s start by focusing our plot on a single spike. As a first step, let’s plot the voltage, and choose the time axis to focus on a single spike,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe’ve now plotted the voltage dynamics for a single spike (and colored the curve black).\nLet’s now plot the three gating variables. To do so, we’ll make another plot.\nLet’s start by displaying the gating variable m over the same x-limits,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNotice that, in the call to plot we included the input label. This will be useful when we create a legend. Within this subplot, we can also simultaneously show the gating variables h and n, with the x-axis labeled.\nLet’s also add a legend to help us keep track of the different curves:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Using the figure you created above, describe how the gates swing open and closed during a spike.\n\n\n\nASIDE: Here’s a nice plotting trick, to link the x-axes of our two subfigures. Linking the axes is useful so that, when we zoom or move one subfigure, the other subfigure will match the x-axis.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow, in the figure, you may use the pan/zoom tool to adjust the linked subplots.\n\n\n5 At high input current (I0), describe the dynamics of the conductances.\nWe have so far explored how the three gates m, h, and n evolve during a spike. By combining these terms, we can visualize how the conductances evolve during a spike. To do so, let’s stick with the simulation results we generated in the previous section, and focus our plot on a single spike,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow, to plot the conductances, let’s define three new variables,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Where do these terms come from?\n\n\n\nThen, let’s plot these conductances,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: How do the conductances evolve during a spike?\n\n\n\nAt high input current (I0), describe the dynamics of the currents. In the previous section, we explored how the three conductances (gNa, gK, gL) evolve during a spike.\nLet’s now visualize how the ionic currents evolve during a spike.\nTo do so, let’s stick with the same settings used in the previous section and examine the same simulation result. Again, we’ll focus our plot on a single spike.\nNow, to plot the current, let’s define the new variables,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: How do the conductances evolve during a spike?\n\n\n\n\n\n\n\n\n\nQ: You may notice a small, transient decrease in the sodium current INa near 47 ms. What causes this?\n\n\n\n\n\n6 Discussion\n\nHow is the HH model different from / similar to the IF and LIF models?\nWhat are the ion species simulated in the HH model?\nWhich ion species is fastest / slowest?\nHow many variables are in the HH model? Define each.\nSketch the model equations, in schematic form, to capture the “essence” of the behavior (don’t worry about the detailed values for parameters).\nWhich gating variables are depolarization activated / depolarization inactivated?\nSketch the steady-state curves for the gating variables.\nConsider the current: I_K=g_K n^4  (E_K-V)\n\nDefine each term.\nHow does this current behave for different values of V?\n\nConsider the current: I_Na=g_Na m^3 h (E_Na-V)\n\nDefine each term.\nHow does this current behave for different values of V?"
  },
  {
    "objectID": "Gamma.html",
    "href": "Gamma.html",
    "title": "Gamma rhythms models",
    "section": "",
    "text": "import matplotlib.pyplot as plt\nimport numpy as np"
  },
  {
    "objectID": "Gamma.html#begin-with-the-inhibitory-synapse-turned-off.",
    "href": "Gamma.html#begin-with-the-inhibitory-synapse-turned-off.",
    "title": "Gamma rhythms models",
    "section": "Begin with the inhibitory synapse turned off.",
    "text": "Begin with the inhibitory synapse turned off.\n\nI0   = 30;    #Set the input drive to excite the cell.\ngI   = 0;     #Turn off inhibitory synapse, to start.\ntauI = 10;    #Set decay time of inhibitory synapse to 10ms.\nT0   = 100;   #Simulate for 100 ms.\n\n[V,s,t] = ing(I0,gI,tauI,T0)\nplt.plot(t,V); plt.xlabel('Time [ms]'); plt.ylabel('Voltage [mV]');"
  },
  {
    "objectID": "Gamma.html#turn-on-the-inhibitory-synapse.",
    "href": "Gamma.html#turn-on-the-inhibitory-synapse.",
    "title": "Gamma rhythms models",
    "section": "Turn on the inhibitory synapse.",
    "text": "Turn on the inhibitory synapse.\n\ngI = 'SOMETHING'\n[V,s,t] = ing(I0,gI,tauI,T0);\nplt.subplot(2,1,1)\nplt.plot(t,V); plt.xlabel('Time [ms]'); plt.ylabel('Voltage [mV]');\nplt.subplot(2,1,2)\nplt.plot(t,s,'r'); plt.xlabel('Time [ms]'); plt.ylabel('Inhibitory synaptic gate');\n\nQ: How does the spiking frequency change?\nQ: How do the synapses evolve?\nQ: This model captures 3 experimental observations we discussed in class. To generate gamma, 1) The cell needs sufficient excitatory drive, 2) The GABA synapse is critical, and 3) Altering the decay time of the inhibitory synapse changes the gamma frequency.\nShow that all three observations are captured by this model."
  },
  {
    "objectID": "Introduction.html",
    "href": "Introduction.html",
    "title": "Introduction to Python for the practicing neuroscientist",
    "section": "",
    "text": "To be frank: this notebook is rather boring. In this class, we will use the software package Python. The best way to learn new software (and probably most things) is when motivated by a particular problem. Would you read assembly instructions for furniture you do not plan to own? Probably not. In other notebooks we will pursue specific questions driven by neuronal data, and use our desire to understand these data to motivate the development and application of computational methods. But not in this notebook. Here, we focus on basic coding techniques and principles in Python in the abstract, without motivation. You - poor learner - must trust that these ideas and techniques will eventually be useful. We begin by dipping our toe into the Python pool, and learning the basic strokes; the fun and interesting parts in the “real world” of neuronal data happen later.\nLet us delay no further. In the following examples, you are asked to execute code in Python. If your Python experience is limited, you should actually do this, not just read the text below. If you intend to ignore this advice - and not execute the code in Python - then instead walk to the local coffee shop, get a double espresso, and return to attempt these examples.\nThis notebook follows in spirit and sometimes in detail notebook 2 of MATLAB for Neuroscientists, an excellent reference for learning to use MATLAB in neuroscience with many additional examples. If you have not used Python before, there are many excellent resources online (e.g., the Python Data Science Handbook).\n\nStarting Python\nThere are two ways to interact with this notebook. First, you could run it locally on your own computer using Jupyter. This is an excellent choice, because you’ll be able to read, edit, and excute the Python code directly and you can save any changes you make or notes that you want to record. The second way is to open this notebook in your browser and execute the examples directly in your browser, without installing additional software on your computer. In any case, we encourage you to execute each line of code in this file!\n\n\n\n\n\n\nNote\n\n\n\nThroughout this notebook, we assume that you are running Python 3. Most of the functions used here are the same in Python 2 and 3. One noteable exception however is division. If you are using Python 2, you will find that the division operator / actually computes the floor of the division if both operands are integers (i.e., no decimal points). For example, in Python 2, 4/3 equals 1. While, in Python 3, 4/3 equals 1.333.\nWe encourage you to use Python 3 for the sake of compatibility with this notebook, as well as for compatibility with future releases of Python.\n\n\n\n\nOn-ramp: analysis of neural data in Python\nWe begin this notebook with an “on-ramp” to analysis in Python. The purpose of this on-ramp is to introduce you immediately to some aspects of Python. You may not understand all aspects of the Python language here, but that’s not the point. Instead, the purpose of this on-ramp is to illustrate what can be done. Our advice is to simply run the code below and see what happens…\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Try to read the code above. Can you see how it loads data, extracts useful information to print, then selects an interval of data to plot?\nA: If you’ve never used Python before, that’s an especially difficult question. Please continue on to learn more!\n\n\n\n\n\nExample 1: Python is a calculator\nExecute the following commands in Python:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What does Python return? Does it make sense?\n\n\n\n\n\nExample 2. Python can compute complicated quantities.\nEnter the following command in Python:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Does this answer make sense?\n\n\n\n\n\n\n\n\n\nQ: Can you use parentheses to change the answer?\n\n\n\n\n\nExample 3. Python has useful built in functions.\nA function is a program that operates on arguments. Standard math functions and variables (and other useful things) can be accessed from the math and numpy modules. To use the math and numpy modules, we must first import both:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nNote\n\n\n\nIn this style, we indicate which module, or namespace, contains the function we want to call: x = np.arange(10) or plt.plot(x, y).\n\n\nYou will often begin your data analysis with import statements, to load the functionality you need. We can now call functions from math using numpy.*. For example,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nAbove, sin is the sine function. It operates on the argument 2*pi. Notice that, once we have imported the numpy module, Python knows the value of pi. Here’s another example function that operates on arguments:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What is math.atan?\nA: To answer this, try using Python Help. To start the Python Help, simply put a ? at the end of math.atan and then run this code block.\n\n\n\n\n\nCode\nmath.atan?\n\n\nYou should see a description of the function pop up at the bottom of the window.\n\n\n\n\n\n\nNote\n\n\n\nPython Help is extremely useful, but may not work in a web browser. You can always look there when you have questions about a function, or search the internet for help, i.e., google it.\n\n\n\n\nExample 4. We can use Python to define lists of numbers.\nIn Python, there are several different data structures that are designed to store more than one element. Here we will focus on the array data structure, but if you are curious to know how and when to use other structures, there is a good explanation here. Let’s define an array:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExample 5. We can manipulate arrays by scalars.\nA scalar is a single number. Consider,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What do you find?\nA: Notice that the scalar operates on each element of the array.\n\n\n\n\n\nExample 6. We can manipulate arrays with arrays.\nLet’s create an array and multiply it by itself,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What does this return?\nA: We see that the operator * performs element-by-element multiplication of the values in array a.\n\n\n\n\n\nExample 7. More examples of manipulating arrays with arrays.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What operation does np.multiply() perform?\n\n\n\n\n\nExample 8. We can probe the variables we’ve defined in Python.\nTo see a list of the variables you’ve defined, type who or whos in a code block by themselves. Notice whos provides more information.\n\n\nCode\nwho\n\n\nInteractive namespace is empty.\n\n\n\n\nCode\nwhos\n\n\nInteractive namespace is empty.\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe functions who and whos can be extremely useful, but may not work in a web browser.\n\n\n\n\nExample 9. Determine the dimensions of an array\nTo examine the dimensions of an array, we can ask for the shape,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe find that the shape of a is (1,4) or 1 row and 4 columns. Notice we have two options to execute the shape function:\n\nIn a.shape we return the attribute shape of the variable a.\nIn np.shape(a) we apply the function shape from numpy to the variable a.\n\nThe result is equivalent.\n\n\nExample 10. Sometimes we need to reset the workspace\nBy doing so, we get rid of all the variables. To do so, type %reset and enter y\n\n\nCode\n%reset\n\n\n\n\n\n\n\n\nQ. What command could we use to confirm there are no variables in the workspace?\nA. Consider who.\n\n\n\n\n\nCode\nwho\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe %reset command is an example of a magic. Magics are commands that start with the % symbol and use a language other than Python. They are only available in the notebook environment. In fact, the set of magics that is available is specific to the notebook kernel. This means that if you have a Jupyter notebook running a Ruby kernel the magics will be different.\n\n\n\n\nExample 11. We can define matrices in Python.\nA matrix is an array with more than one dimensio. Consider the following:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis creates a matrix with two rows and three columns. Consider,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Can you see the two rows and three columns?\n\n\n\nWe can manipulate matrices like we manipulate vectors.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExample 12. Indexing matrices and vectors.\nMatrices and vectors are arrays of numbers, and sometimes we want to access individual elements or small subsets of these lists. That’s easy to do in Python. Consider,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nPython indexes from 0 (like C, C++, Java, and unlike MATLAB and Fortran which start at 1). To access the 2nd element of a or b, type a[1] / b[1]. We’ll be a bit fancier with our printing now to distinguish variables. Calling str(a) converts the variable a to a string that can be printed easily. Adding two strings just concatenates them: \"hi\" + \" bye\" = \"hi bye\".\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ. Do the results make sense? How would you access the 4th element of each vector?\n\n\n\nWe can combine a and b to form a matrix with a as the first row and b as the second. Note that we apply the function array() to the list [a,b], which it converts to a matrix.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nTo learn the size (or shape) of c we use shape():\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe shape of c is [2 5]. It has two rows and five columns. To access the individual element in the 1st row and 4th column of c, type c[0,3]\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nWe access matrices using ‘row, column’ notation. So c[0,3] means print the element in row 0, column 3 of c.\n\n\n\n\n\n\n\nQ. How would you print all rows in the 2nd column of c?\n\n\n\n\n\nExample 13: We can find subsets of elements in matrices and vectors.\nOften we are interested in only some of the elements of a matrix or vector. For example, we might want to look at the data from a single experimental trial which is stored in a particular row of a matrix. Alternatively, we might want to find out when the values in a time series cross a given boundary. Doing this is simple in Python.\n\nSlicing\nSlicing means that we want to look at a specific portion of a vector or matrix, for example, the first row of a matrix. We will continue with the matrix c from the previous example. The notation ‘:’ means ‘all indices’. To access all columns in the entire first row of c, type c[0,:]. To access the 2nd thru 4th columns of the first row of c, type c[0,1:4].\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nThe notation 1:4 means all integers from 1 up to, but not including 4, which in this case gives columns 1, 2, and 3.\n\nLeaving out the number before the colon tells Python to start at index 0. Leaving out the number after the colon tells Python to continue all the way to the end.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe can also tell Python how to step through the indices. To access only the even columns of c, we can use the following:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis code tells Python to start at 0, continue to the end, and step by 2. The result should be the values in row 0, columns 0, 2, and 4 of c. We could write this explicitly as c[0,0:5:2].\n#### Selecting elements that satisfy a condition Sometimes we’re interested in locating particular values within a matrix or vector. As an example, let’s first define a vector.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ. Calculate the shape of a. What is the maximum value of a? Hint: Use the max() function.\n\n\n\nNow let’s find all values in a that exceed 10.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis is called logical indexing, let’s look at what a&gt;10 returns:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWhen we index a using this array lgIdx we get back only the entries in a corresponding to True, as above:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nSometimes we want to know the actual indices in a where a &gt; 10. We can get them using the nonzero() array method, which returns the index of all entries that were True, or non-zero.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nThe command nonzero() can be used as both a function and a method. A method is called by adding it after the object it is meant to operate on with a period in between ( lgIdx.nonzero() ). A function is called with the argument explicitly provided inside the parentheses ( nonzero(lgIdx) ). Basically, a function and a method do the same thing, but a function needs to be given an argument, while a method assumes that the argument is the object that the method is attached to. Note that if we use nonzero() as a function, we need to tell it to look in NumPy for the definition (i.e. add `` at the beginning of the function call).\n\nNow we have another way to select the desired elements of a:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe can use these two types of indexing to change subsets of the values of a.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: How does a change in the first and second print statements?\n\n\n\nWe can perform these same logical operations for a matrix,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nNotice that the last line collapses the True entries to an array, ordered by row and then by column. If you’ve used MATLAB, this is the opposite of what it does!\n\n\n\n\nExample 14: Plotting data in Python.\nIt’s not easy to look at lists of numbers and gain an intuitive feeling for their behavior, especially when the lists are long. In these cases, it’s better to visualize the lists of numbers by plotting them. Consider\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ. Looking at the values in ‘y’ printed above, can you tell what’s happending?\nA. Not really … let’s visualize y vs x instead.\n\n\n\n\nmatplotlib\nTo visualize y versus x let’s plot it. To do so, let’s first import some basic plotting routines from matplotlib, which provides a nice 2D plotting library. We’ll also tell Python to show matplotlib graphics inline, in this notebook.\nLet’s start by plotting a simple example for x and y,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ. Does the plot above make sense for the variables x and y?\n\n\n\nNow, let’s go back to the definitions of x and y that we started this example with and plot y versus x.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe plot of x versus y should look a bit jagged, and not smooth like a sinusoid. To make the curve smoother, let’s redefine x as,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ. Compare this definition of x to the definition above. How do these two definitions differ?\n\n\n\n\n\n\n\n\n\nQ. What is the size of x? Does this make sense?\n\n\n\nNow let’s replot the sine function.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ. Does this plot make sense, given your knowledge of x, y, and trigonometry?\n\n\n\n\n\n\nExample 15: What if we want to compare several functions?\nContinuing the example in the previous section, let’s define a second vector\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nand plot it:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe’d now like to compare the two variables y and z. To do this, let’s plot both vectors on the same figure, label the axes, and provide a legend,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNotice that we’ve included a third input to the function plot. Here the third input tells Python to draw the curve in a particular color: 'r' for red. There are many options we can use to plot; to see more, check out the documentation for plot.\nWe can also label the axes, give the figure a title, and provide a legend,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nTo futher edit this plot, you might decide - for example - that the font size for the labels is too small. We can change the default with:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExample 16: We can make random numbers in Python.\nTo generate a single Gaussian random number in Python, use the function in the NumPy random module.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLet’s generate a vector of 1000 Gaussian random numbers:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n… and look at a histogram of the vector:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ. Does this histogram make sense? Is it what you expect for a distribution of Gaussian random variables?\n\n\n\n\nSee Python Help (hist?) to learn about the function hist().\n\n\n\nExample 17: Sampling randomly from a vector (courtsey of vgascue)\nUsing the random module from numpy one can also take a random sample from a vector. Let’s take 5 random samples from the vector “r” generated in example 16.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nTry running it more the one time to see how the output changes!\n\n\nExample 18: Repeating commands over and over and over . . .\nSometimes we’ll want to repeat the same command over and over again. For example, what if we want to plot sin(x + k*pi/4) where k varies from 1 to 5 in steps of 1; how do we do it? Consider the following:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThat’s horrible code! All I did was cut and paste the same thing four times. As a general rule, if you’re repeatedly cutting and pasting in code, what you’re doing is inefficient and typically error prone. There’s a much more elegant way to do this, and it involves making a for loop. Consider:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow let’s declare a for loop where k successively takes the values 1, then 2, then 3, …, up to 5. Note, any code we want to execute as part of the loop must be indented one level. The first line of code that is not indented, in this case show() below, executes after the for loop completes\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe small section of code above replaces all the cutting-and-pasting. Instead of cutting and pasting, we update the definition of y with different values of k and plot it within this for-loop.\n\n\n\n\n\n\nQ. Spend some time studying this for-loop. Does it make sense?\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nImportant: Python uses indentation to define for loops.\n\n\n\n\nExample 19: Defining a new function.\nWe’ve spent some time in this notebook writing and executing code. Sometimes we’ll need to write our own Python functions. Let’s do that now.\nOur function will do something very simple: it will take as input a vector and return as output the vector elements squared plus an additive constant.\nIf have a vector, v, and a constant, b, we would like to call:\nvsq = my_square_function(v, b)\nThis won’t work! We first need to define my_square_function. Let’s do so now,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe function begins with the keyword def followed by the function name and the inputs in parentheses. Notice that this first line ends with a colon :. All of the function components that follow this first line should be indented one level. This is just like the for loop we applied earlier; the operations performed by the for loop were indented one leve.\n\nWhen defining the function, the code the function executes should be indented one level.\n\nThe text inside triple quotes provides an optional documentation string that describes our function. While optional, including a ‘doc string’ is an important part of making your code understandable and reuseable.\nThe keyword return exits the function, and in this case returns the expression x * x + c. Note that a return statement with no arguments returns None, indicating the absence of a value.\nWith the function defined, let’s now call it. To do so we first define the inputs, and then run the function, as follows:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ. Try to make a function, my_power, so that y = power(x,n) evaluates \\(y = x^n\\), (in Python you can use x**n to take the power)\n\n\n\n\n\nExample 20: Load data into Python\nFor our last example let’s load a data file on the web in the .csv format into Python.\nTo do so, let’s first import the pandas module,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow, let’s load a data file using the function read_csv,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe variable df that holds the loaded data is a Python DataFrame. We can think of it as a simple table that holds our data.\nLet’s print it,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe see that the columns in the dataframe consist of two variables: d and t. Our collaborator who provided the data tells us that these correspond to the voltage recording (d) and a time axis (t) for her data.\nLet’s define variables to hold the data corresponding to each key,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nNote\n\n\n\nHere we convert the data in each column to a numpy array, because we’d (probably) like numpy to function on these values.\n\n\nNow, let’s plot the LFP data versus the time axis,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExample 21: Compute statistics and compare (courtesy of mateouma)\nLet’s do some statistics. First, our standard imports.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWith numpy, we can find the mean and standard deviation of our LFP data.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow, let’s use numpy to randomly generate numbers according to a normal distribution with the same mean and standard deviation as the LFP data. The syntax is np.random.normal(mean, sd, size), where mean, sd, and size are variables or numbers.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe can use a histogram to compare the distribution of the data with a normal distribution with the same mean and standard deviation.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nAs we can see, our data doesn’t look normally distributed, but in practice we should use a statistical test to make this assessment.\n\n\nExample 22: Recursion (courtsey of marieshi)\nLet’s consider a classic mathematical sequence: the Fibonacci sequence. This is a sequence that starts with 0 and 1, and each number is the sum of the preceding two numbers in the sequence.\nLet’s use this sequence to expand our knowledge of functions.\nWe use recursive functions when we want to call the function itself within the function.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe can think of recursive functions algorithmically: it usually starts with one or more base cases, or the simplest form of the function. This defines the behavior and serve as an anchor.\nNext are the recursive calls, which simplifies the problem iteratively, usually by calling the function back onto itself.\n\n\n\n\n\n\nQ. What is the difference between using recursion and loops in this case? Do you see any benefits?\n\n\n\nRecursion tends to be most functional when analyzing tree or nested structures.\nFor example, if you are writing code and have a lot of parantheses you can’t keep track of, we can use recursion to see if they are balanced.\nTo keep this a bit simpler, let’s pretend that you have extracted all the parantheses and just need to check if a string of open or closed parantheses are balanced.\nFor example, () is balanced, )))((( or (() are not.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLet’s test our function out!\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  },
  {
    "objectID": "Hopfield.html",
    "href": "Hopfield.html",
    "title": "Hopfield networks",
    "section": "",
    "text": "1 Simulate a Hopfield network\n\n\nCode\n#```{pyodide-python}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define \nN = 20\nK = 200\nS = np.zeros([N,K])\n\n# Set initial values for S\nS[:,0] = np.random.choice([0, 1], size=(N,))  # Pattern \n\n# Define connectivity\nTij = np.random.rand(N,N)\n\n# Do the updates\nU_threshold = 0\nfor k in np.arange(K)-1:\n    # Get the neurons now, at time t.\n    St = S[:,k]\n    \n    # Choose a random neuron\n    random_neuron = np.random.randint(0, N)\n    \n    # Compute input to that neuron\n    input_to_neuron = (Tij @ St)[random_neuron]\n    if input_to_neuron &gt; U_threshold:\n        S[random_neuron,k+1] = 1\n    else:\n        S[random_neuron,k+1] = 0\n\nf = plt.figure()\nplt.imshow(1-S, cmap='gray')\nf.set_size_inches((30,200))\nplt.xlabel('Time')\nplt.ylabel('Neuron Number')\nplt.show();\n#```\n\n\n\n\n2 Information storage & Pseudoorthogonality\nDefine two patterns to store xi and another pattern S\n\n\nCode\n#```{pyodide-python}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define a pattern to store\nN  = 100\nV  = np.random.choice([0, 1], size=(N,))  # Pattern to store\nxi = 2*V-1\nprint(xi)\n\n# Define another pattern\nV  = np.random.choice([0, 1], size=(N,))  # Another pattern\nS  = 2*V-1\nprint(S)\n\n# Compute the term in red square brackets from the slides\nnp.sum(xi * S)\n#```\n\n\nRepeat the computation in red square brackets many times, with different random choices of patterns to store.\n\n\nCode\n#```{pyodide-python}\nK = 100;\nsquare_bracket_term = np.zeros(K)\nfor k in np.arange(K):\n    xi = np.random.choice([-1, 1], size=(N,))  # Random pattern\n    S  = np.random.choice([-1, 1], size=(N,))  # Another random pattern\n\n    square_bracket_term[k] = np.sum(xi * S)\n\nplt.figure()\nplt.hist(square_bracket_term)\nplt.axvline(x=0, color='red', linestyle=':')\nplt.xlabel('Term in square brackets')\nplt.show();\n#```\n\n\nRepeat the computation in red square brackets many times, with the input pattern S overlapping with the stored pattern xi.\n\n\nCode\n#```{pyodide-python}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nN         = 100\nN_overlap = 50\n\nK = 50\nsquare_bracket_term = np.zeros(K)\nfor k in np.arange(K):\n    xi = np.random.choice([-1, 1], size=(N,))  # Random pattern\n    S  = np.random.choice([-1, 1], size=(N,))  # Another random pattern\n    S[0:N_overlap] = xi[0:N_overlap]           # ... make it overlap with the first pattern at N_overlap neurons\n    square_bracket_term[k] = np.sum(xi * S)\n\nplt.figure()\nplt.hist(square_bracket_term)\nplt.axvline(x=0, color='red', linestyle=':')\nplt.xlabel('Term in square brackets')\nplt.show();\n#```|\n\n\n\n\n3 Simulate Hopfield dynamics with one stored pattern\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define a pattern to save\nN  = 100\nxi1 = np.random.choice([-1, 1], size=(N,))\n\n# Compute Tij\nTij = np.outer(xi1, xi1)\nnp.fill_diagonal(Tij, 0)\nplt.imshow(Tij);\n\n# Send in new state\nproportion_of_xi1 = 0.75\nS = np.append(xi1[:int(proportion_of_xi1*N)], np.random.choice([-1, 1], size=(int((1-proportion_of_xi1)*N),)))\nprint(S)\n\n# Input\nplt.figure()\nplt.subplot(4,1,1)\nplt.stem(S); plt.title('S original'); plt.grid()\n\nplt.subplot(4,1,2)\nplt.stem(xi1); plt.title('xi1'); plt.grid()\n\n# Update in time\nK = 1000\nerror = np.zeros(K);\nfor k in np.arange(K):\n    # Choose a random neuron\n    random_neuron = np.random.randint(0, N)\n    \n    # Compute input to that neuron\n    input_to_neuron = (Tij @ S)[random_neuron]\n    if input_to_neuron &gt; 0:\n        S[random_neuron] = 1\n    else:\n        S[random_neuron] = -1\n    error[k] = (np.sum(np.abs(S - xi1)))\n\nplt.subplot(4,1,3)\nplt.stem(S, 'r'); plt.title('S final'); plt.grid()\n\nplt.subplot(4,1,4)\nplt.plot(error)\nplt.axhline(0)\n\nplt.tight_layout()\n\n\n\n\n4 Simulate Hopfield dynamics with two stored patterns\n\n\nCode\nN   = 5\ncsi = [1,-1,-1,1,1] #np.random.choice([-1, 1], size=(N,))  # Pattern \nW   = np.outer(csi, csi)\nnp.fill_diagonal(W, 0)\nprint(csi)\nprint('\\n')\nprint(W)\n\n\n\n\nCode\ndef sign(x):\n    \"\"\"\n    Returns +1 if x &gt; 0, otherwise -1.\n    Works for scalars and numpy arrays.\n    \"\"\"\n    return np.where(x &gt; 0, 1, -1)\n\n\n\n\nCode\nT=10;\nS=np.zeros([np.size(csi), T])\nS[:,0] = np.random.choice([-1, 1], size=(np.size(csi),))\n\nfor k in np.arange(T-1):\n    S[:,k+1] = sign(np.dot(W,S[:,k]))\nprint(S)\nprint(S[:,-1] - csi)\nstarting_values_correct = csi == S[:,0]\nprint(starting_values_correct,' Number of correct starting values = ',np.sum(starting_values_correct))\n\n\n\n\nCode\nnp.sum(starting_values_correct)\n\n\n\n\nCode\nimport numpy as np\n\ndef make_pattern(pattern_type, size=5):\n    \"\"\"\n    Returns a size×size numpy array of 0s and 1s for the requested pattern:\n      - 'checkerboard': alternating 0/1 cells\n      - 'X': 1s on both diagonals\n      - 'A': block letter 'A' (only defined for size=5)\n    \"\"\"\n    if pattern_type == 'checkerboard':\n        return np.fromfunction(lambda i, j: (i + j) % 2, (size, size), dtype=int)\n    elif pattern_type == 'X':\n        mat = np.zeros((size, size), dtype=int)\n        idx = np.arange(size)\n        mat[idx, idx] = 1\n        mat[idx, size - 1 - idx] = 1\n        return mat\n    elif pattern_type == 'A':\n        if size != 5:\n            raise ValueError(\"Pattern 'A' is only defined for a 5×5 matrix.\")\n        mat = np.zeros((5, 5), dtype=int)\n        # Apex and legs\n        mat[0, 2] = 1\n        mat[1, 1] = 1; mat[1, 3] = 1\n        # Crossbar\n        mat[2, :] = 1\n        # Legs continue\n        mat[3, 0] = 1; mat[3, 4] = 1\n        mat[4, 0] = 1; mat[4, 4] = 1\n        return mat\n    else:\n        raise ValueError(f\"Unknown pattern_type '{pattern_type}'.\")\n\ndef to_vector(mat):\n    return mat.reshape(-1)\n\ndef sign(x):\n    # note: ≥0 → +1, otherwise −1\n    return np.where(x &gt;= 0, 1, -1)\n\ndef noisy_bipolar(pattern, noise_level):\n    \"\"\"\n    pattern: 1-D array of ±1\n    noise_level: fraction of bits to flip (multiply by −1)\n    \"\"\"\n    noisy = pattern.copy()\n    n = noisy.size\n    k = int(noise_level * n)\n    if k&gt;0:\n        idx = np.random.choice(n, k, replace=False)\n        noisy[idx] *= -1\n    return noisy\n\n# 1) build your three bipolar memories\nc1 = 2*to_vector(make_pattern('checkerboard')) - 1\nc2 = 2*to_vector(make_pattern('X'))           - 1\nc3 = 2*to_vector(make_pattern('A'))           - 1\n\n# 2) train weight matrix\nW = np.outer(c1, c1) + np.outer(c2, c2) + np.outer(c3, c3)\nnp.fill_diagonal(W, 0)\n\n# 3) create a noisy test pattern (flip 10% of bits in c1)\nS = noisy_bipolar(c2, noise_level=0.0)\nS_true = (S &gt; 0).astype(int).reshape(5, 5)\nS = noisy_bipolar(c2, noise_level=0.2)\nS0 = (S &gt; 0).astype(int).reshape(5, 5)\n\n# 4) iterate until convergence (synchronous update)\nfor _ in range(10):\n    S_new = sign(W.dot(S))\n    if np.array_equal(S_new, S):\n        break\n    S = S_new\n\n# 5) convert back to 0/1 for display if you like\nS_recalled = (S &gt; 0).astype(int).reshape(5, 5)\n\nimport matplotlib.pyplot as plt\nplt.subplot(1,3,1)\nplt.title(\"True input\")\nplt.imshow(S_true, cmap='gray_r')\nplt.axis('off')\n\nplt.subplot(1,3,2)\nplt.title(\"Noisy input\")\nplt.imshow(S0, cmap='gray_r')\nplt.axis('off')\n\nplt.subplot(1,3,3)\nplt.title(\"Recalled\")\nplt.imshow(S_recalled, cmap='gray_r')\nplt.axis('off')\nplt.show()\n\n\n\n\nCode\ndef to_vector_flat(mat):\n    \"\"\"\n    Flattens a (100, 100) matrix into a 1-D array of length 10000.\n    \"\"\"\n    return mat.reshape(-1)\n\ndef to_matrix(vec):\n    \"\"\"\n    Reshapes a (10000, 1) vector back into a (100, 100) matrix.\n    \"\"\"\n    return vec.reshape(100, 100)\n\ndef sign(x):\n    \"\"\"\n    Returns +1 if x &gt; 0, otherwise -1.\n    Works for scalars and numpy arrays.\n    \"\"\"\n    return np.where(x &gt; 0, 1, -1)\n\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create a 100x100 zero matrix\nmatrix = np.zeros((100, 100), dtype=int)\n\n# Draw the letter B\n# Vertical bar\nmatrix[:, 5:15] = 1\n# Top loop\nmatrix[0:10, 5:35] = 1\nmatrix[0:50, 30:40] = 1\nmatrix[40:50, 5:35] = 1\n# Bottom loop\nmatrix[50:60, 5:35] = 1\nmatrix[50:100, 30:40] = 1\nmatrix[90:100, 5:35] = 1\n\n# Draw the letter U\n# Left vertical\nmatrix[0:90, 60:70] = 1\n# Right vertical\nmatrix[0:90, 85:95] = 1\n# Bottom bar\nmatrix[90:100, 60:95] = 1\n\n# Display the matrix as an image\nplt.figure(figsize=(5, 5))\nplt.imshow(matrix, interpolation='nearest')\nplt.axis('off')\nplt.show()\n\nBU = matrix\ncsi_BU = to_vector_flat(BU)\n\n\n\n\nCode\nW   = np.outer(csi_BU, csi_BU)\nnp.fill_diagonal(W, 0)\n\nplt.imshow(W, interpolation='nearest');\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create a 100x100 zero matrix\nmatrix = np.zeros((100, 100), dtype=int)\n\n# Draw the letter B (left side)\n# Vertical spine\nmatrix[:, 5:15] = 1\n# Top loop top bar\nmatrix[0:10, 5:35] = 1\n# Top loop right bar\nmatrix[0:50, 30:40] = 1\n# Middle bar\nmatrix[40:50, 5:35] = 1\n# Bottom loop top bar\nmatrix[50:60, 5:35] = 1\n# Bottom loop right bar\nmatrix[50:100, 30:40] = 1\n# Bottom loop bottom bar\nmatrix[90:100, 5:35] = 1\n\n# Draw the letter C (right side)\n# Top horizontal bar\nmatrix[0:10, 60:95] = 1\n# Vertical bar\nmatrix[:, 60:70] = 1\n# Bottom horizontal bar\nmatrix[90:100, 60:95] = 1\n\n# Display the matrix as an image\nplt.figure(figsize=(5, 5))\nplt.imshow(matrix, interpolation='nearest')\nplt.axis('off')\nplt.show()\n\nBC = matrix\ncsi_BC = to_vector_flat(BC)\n\n\n\n\nCode\nT=5;\nS=np.zeros([np.size(csi_BU), T])\nS[:,0] = 1*csi_BC + np.random.choice([-1, 1], size=(np.size(csi_BU),))\n\nfor k in np.arange(T-1):\n    print(k)\n    S[:,k+1] = sign(np.dot(W,S[:,k]))\nplt.figure(); plt.imshow(to_matrix(S[:,0]));\nplt.figure(); plt.imshow(to_matrix(S[:,1]));\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create a 100×100 zero matrix\nmatrix = np.zeros((100, 100), dtype=int)\n\n# Draw an 8-point \"star\" by setting ones on:\n# - the center row\n# - the center column\n# - the two diagonals\nidx = np.arange(100)\ncenter = 50\n\nmatrix[center, :] = 1         # horizontal line\nmatrix[:, center] = 1         # vertical line\nmatrix[idx, idx] = 1          # main diagonal\nmatrix[idx, 99 - idx] = 1     # anti-diagonal\n\n# Display the result\nplt.figure(figsize=(5, 5))\nplt.imshow(matrix, interpolation='nearest')\nplt.axis('off')\nplt.show()\n\nstar = matrix;\ncsi_star = to_vector_flat(star)\n\n\n\n\nCode\nW2   = 1*np.outer(csi_BU, csi_BU) + np.outer(csi_BC, csi_BC)\nnp.fill_diagonal(W2, 0)\nW2   = 1/np.size(csi_BU) * W2\n\n\n\n\nCode\nnp.shape(S)\n\n\n\n\nCode\nT=2;\nS=np.zeros([np.size(csi_BU), T])\nS[:,0] = 1*csi_BU + 1*np.random.choice([-1, 1], size=(np.size(csi_BU),))\nS[5000::,0] = 0\n\nfor k in np.arange(T-1):\n    print(k)\n    S[:,k+1] = sign(np.dot(W2,S[:,k]))\nplt.figure(); plt.imshow(to_matrix(S[:,0]));\nplt.figure(); plt.imshow(to_matrix(S[:,1]));\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define a pattern to save\nN  = 100\nxi1 = np.random.choice([-1, 1], size=(N,))\n\n# Define another pattern to save\nxi2 = np.random.choice([-1, 1], size=(N,))\n\n# Compute Tij\nTij = np.outer(xi1, xi1) + np.outer(xi2, xi2)\nnp.fill_diagonal(Tij, 0)\nplt.imshow(Tij);\n\n# Send in a nearby state (3/4 of Vs1, 1/4 of Vs2)\nproportion_of_xi1 = 0.75\nS = np.append(xi1[:int(proportion_of_xi1*N)], xi2[int(proportion_of_xi1*N):])\nprint(S)\n\n# Input\nplt.figure()\nplt.subplot(4,1,1)\nplt.stem(S); plt.title('S original'); plt.grid()\n\nplt.subplot(4,1,2)\nplt.stem(xi1); plt.title('xi1'); plt.grid()\n\n# Update in time\nK = 1000\nerror = np.zeros(K);\nfor k in np.arange(K):\n    # Choose a random neuron\n    random_neuron = np.random.randint(0, N)\n    \n    # Compute input to that neuron\n    input_to_neuron = (Tij @ S)[random_neuron]\n    if input_to_neuron &gt; 0:\n        S[random_neuron] = 1\n    else:\n        S[random_neuron] = -1\n    error[k] = (np.sum(np.abs(S - xi1)))\n\nplt.subplot(4,1,3)\nplt.stem(S, 'r'); plt.title('S final'); plt.grid()\n\nplt.subplot(4,1,4)\nplt.plot(error)\nplt.axhline(0)\n\nplt.tight_layout()"
  },
  {
    "objectID": "Linear_Algebra.html",
    "href": "Linear_Algebra.html",
    "title": "1. Vectors",
    "section": "",
    "text": "import numpy as np\n\nv = np.array([[3], [1], [-7]])\nprint(v)\n\n\nv.T\n\nprint(v.T)\n\n\nvA = np.array([[3, 1, -7]])  # -&gt; 2D row vector (1 row, 3 columns)\nprint(vA)\n\nvA[0, 1]  #indexing matters! Get (row 0, column 1)\nvA[1]\n\n\nvB = np.array([3, 1, -7]) #-&gt; 1D array with 3 elements with no row/col distinction\nprint(vB)\n\nvB[1]     #indexing matters! Get (second element)\n\n\n2. Vector norm\n\nv = np.array([1,7,3,0,1])\n\n\nnp.linalg.norm(v)\n\n\nnp.sqrt(np.dot(v,v))\n\n\nnp.sqrt(v.T @ v)\n\n\nnp.sqrt(np.sum(v*v))\n\n\nnp.sqrt(np.sum(v**2))\n\n\n\n3. Inner product\n\nv1 = np.array([1,2,3])\nv2 = np.array([3,2,-1])\nv3 = np.array([10,0,5])\n\n\nnp.sum(v1*v2)\n\n\nnp.dot(v1,v2)\n\n\n\n3. Linear projection\n\nw = np.array([2,2])\nv1 = np.array([2,1])\n#v1 = np.array([2,0]) \n#v1 = np.array([5,0]) \n\n# Create the plot\nimport matplotlib.pyplot as plt\nplt.figure()\nplt.quiver(0, 0, w[0], w[1], angles='xy', scale_units='xy', scale=1)\nplt.quiver(0, 0, v1[0], v1[1], angles='xy', scale_units='xy', scale=1)\nplt.xlim(-1, 5)  # Set plot limits a bit beyond the vectors\nplt.ylim(-1, 5)\nplt.grid()\nplt.xlabel('x')\nplt.ylabel('y')\nplt.gca().set_aspect('equal', adjustable='box')\n\nprint(np.dot(w, v1))\n\nprint(np.dot(w, v1)/np.sqrt(np.dot(v1,v1)))"
  }
]
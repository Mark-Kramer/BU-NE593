{"title":"Leaky Integrate and Fire Neuron","markdown":{"yaml":{"title":"Leaky Integrate and Fire Neuron","project":{"type":"website"},"format":{"html":{"code-fold":true,"code-tools":true}},"jupyter":"python 3","number-sections":true,"filters":["pyodide"]},"headingText":"Preliminaries","containsRefs":false,"markdown":"\n\nIn this notebook we will use Python to simulate the leaky integrate and fire (LIF) neuron model.  We'll investigate, in particular, how the spiking activity varies as we adjust the input current $I$.\n\nBefore beginning, let's load in the Python package we'll need:\n\n```{pyodide-python}\nimport numpy as np\nimport matplotlib.pyplot as plt\n```\n\n#  Numerical solutions - Introduction\n\n \nHow do we compute a numerical solution to the integrate and fire model?\n  The basic idea is to rearrange the differential equation to get $V(t+1)$ on\n  the left hand side, and $V(t)$ on the right hand side.  Then, if we know\n  what's happening at time $t$, we can solve for what's happening at time $t+1$.\n\nFor example, consider the differential equation:\n\n$$\n  \\dfrac{dV}{dt} = -\\dfrac{V-V_*}{\\tau}\n$$\n\nIn words, we can think of:\n\n$dV$ as the \"change in voltage V\",\n\n$dt$ as the \"change in time t\".\n\nLet's consider the case that we record the voltage $V$ in discrete time steps. So\nwe observe:\n\n$V[0], V[1], V[2], \\ldots$\n\nat times:\n\n$dt, \\, 2*dt, \\, 3*dt, \\ldots$\n\nwhere $dt$ is the time between our samples of $V$.\n\nWe can now write the \"change in voltage V\" as:\n\n$$\n  dV = V(t+1) - V(t)\n$$\n\nNotice that the change in voltage is the difference in V between two\nsequential time samples.  Now, let's rewrite $\\dfrac{dV}{dt}$ as,\n\n$$\n  \\dfrac{dV}{dt} = \\dfrac{ V(t+1) - V(t) }{ dt } \n$$\n\nwhere we've replaced $dV$.  Now, let's substitute this expression into the equation at the top of this file:\n\n$$\n  \\dfrac{ V(t+1) - V(t) }{ dt } = \\dfrac{I}{C}.  \n$$\n\nSolving this equation for $V(t+1)$ you'll find  that:\n\n$$\n  V(t+1) = V(t) + dt*(-\\dfrac{V(t)-V_*}{\\tau})\n$$\n\nNotice that, in this expression, we use our current value of the voltage $V(t)$ and the model ($-\\dfrac{V(t)-V_*}{\\tau}$) to determine the next value of the voltage V(t+1).\n\nNow, let's program this equation in Python.  First, let's set the values\nfor the parameters $V_*$ and $\\tau$.\n\n```{pyodide-python}\nVstar=1.0\ntau  =1.0\n```\n\n  We also need to set the value for $dt$.  This defines the time step for our\n  model.  We must choose it small enough so that we don't miss anything\n  interesting.  We'll choose:\n\n```{pyodide-python}\ndt=0.01\n```\n\nLet's assume the units of time are seconds.  So, we step forward in time by $0.01$ s.\n\nThe right hand side of our equation is nearly defined, but we're still missing one thing, $V(t)$.\n\n::: {.callout}\n**Q:**  What value do we assign to $V(t)$?\n:::\n\nSo here's an easier question:  what *initial* value do we assign to $V(t)$?\n \n To start, we'll create an array of zeros to hold our results for $V$:\n\n```{pyodide-python}\nV = np.zeros([1000,1])\nnp.shape(V)\n```\n\nThis array `V` consists of 1000 rows and 1 column. We can think of each row entry as corresponding to a discrete step in time. Our goal is to fill-in the values of `V` (i.e., step forward in time), in a way consistent with our model.\n\nLet's choose an initial value for `V` of 0.2, which in our simple model we'll assume represents the rest state.\n\n```{pyodide-python}\nV[0]=0.2\n```\n\n::: {.callout}\n**Q:**  Given the initial state `V[0]=0.2`, calculate `V[1]`.  Then calcualte `V[2]`.\n:::\n\n  After the two calculations above, we've moved forward two time steps into\n  the future, from $t=0$ s to $t=0.01$ s, and then from $t=0.01$ s to $t=0.02$ s.  But what\n  if we want to know $V$ at $t=10$ s?  Then, this iteration-by-hand procedure becomes\n  much too boring and error-prone.  So, what do we do?  Let's make the\n  computer do it ...\n\n# Numerical solutions - Implementation\n\nLet's computerize this iteration-by-hand procedure to find `V[999]`.\n\nTo do so, we'll use a [for-loop](https://wiki.python.org/moin/ForLoop).\n\nHere's what it looks like:\n\n```{pyodide-python}\nfor k in range(1,999):\n    V[k+1] = V[k] + dt*(\"something\")\n```\n\n::: {.callout}\n**Q:**  Does this loop make sense?  Describe what's happening here. What is `something`?\n:::\n\n::: {.callout}\n**Q:**  Why does the `range` command end at `999`?\n:::\n\nExecute this for-loop and examine the results in vector `V`.  To do so, let's plot `V`:\n\n```{pyodide-python}\nplt.figure()\nplt.plot(V)\nplt.show()\n```\n\n::: {.callout}\n**Q:**  What happens to the voltage after 1000 steps?\n:::\n\n  This plot is informative, but not great.  Really, we'd like to plot the\n  voltage as a function of *time*, not steps or indices.  To do so, we\n  need to define a time axis:\n\n```{pyodide-python}\nt = np.arange(0,len(V))*dt\n```\n\n::: {.callout}\n**Q:**  What's happening in the command above?  Does it make sense?  (If not, trying printing or plotting `t`.)\n:::\n\nNow, with *time* defined, let's redo the plot of the voltage with the axes labeled appropriately.\n\n```{pyodide-python}\nplt.figure()\nplt.plot(t,V)\nplt.xlabel('Time [s]')\nplt.ylabel('V')\nplt.show()\n```\n\nFinally, let's put it all together . . .\n\n# LIF CODE (version 1)\n\n  So far, we constructed parts of the I&F model in bits-and-pieces.\n  Let's now collect all the code, compute a numerical solution to\n  the I&F model, and plot the results (with appropriate axes).\n\n```{pyodide-python}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nVstar   = 1                           #Set the parameter Vstar.\ntau  = 1                              #Set the parameter tau.\ndt  = 0.01                            #Set the timestep.\nV   = np.zeros([1000,1])              #Initialize V.\nV[0]= 0.2;                            #Set the initial value of V.\n\nfor k in range(1,999):                #March forward in time,\n    V[k+1] = V[k] + dt*(\"something\")  #... updating V along the way.\n\nt = np.arange(0,len(V))*dt            #Define the time axis.\n\nplt.figure()\nplt.plot(t,V)                         #Plot the results.\nplt.xlabel('Time [s]')\nplt.ylabel('Voltage [mV]')\nplt.show()\n```\n\n::: {.callout}\n**Q:**  Adjust the parameter `Vstar`.  What happens to `V` if `Vstar=0`?  Can you set `Vstar` so that `V` > 20 within 10 s?\n:::\n\n# Voltage threshold & reset\n\n  Notice, our model is missing something important:  **the reset**.\n\n::: {.callout}\n**Q:**  Without the reset, how does the voltage behave as $t\\rightarrow\\infty$ (if $Vstar>0$)?\n:::\n\n Now, let's update our model to include the reset.  To do so, we'll add two things to our code.\n  \n  - First, we'll define the voltage threshold `Vth`, and\n  reset voltage `Vreset`.\n  - Second, we'll check to see if `V` exceeds\n  `Vth` using an [if-statement](https://docs.python.org/3/tutorial/controlflow.html);  if it does, then we'll set `V` equal to\n  `Vreset`.\n\n::: {.callout}\n**Q:**  How will you update the code below to include the reset?\n:::\n\n```{pyodide-python}\nVth    =  25;     #Define the voltage threshold.\nVreset = -10;     #Define the reset voltage.\n\nfor k in range(1,999):                #March forward in time,\n    V[k+1] = V[k] + dt*(\"something\")  #... updating V along the way.\n    ### ADD SOMETHING HERE??? --------------------------\n```\n\n# I&F CODE (version 2)\n\nNow, let's put it all together to make a complete I&F model (with a thershold and reset), simulate it, and plot the result.\n\n```{pyodide-python}\n### ADD YOUR CODE!\n```\n\n::: {.callout}\n**Q:** Adjust the parameter `I`.  What happens to `V` if `I=10`?  If `I=100`?\n:::\n\n::: {.callout}\n**Q:** Adjust the parameter `C`.  What happens to `V` if `C=0.1`?  If `C=10`?\n:::\n\n::: {.callout}\n**Q:** What is \"spiking\" in this I&F model?\n:::\n\n---\n\n# Discussion\n\n1. Describe the main components of the **IF** model. Draw it (in some way).\n   \n3. Describe the main components of the **LIF** model. Draw it (in some way).\n4. Describe the differences and similarities between the IF and LIF models.\n5. The IF model is meant to mimic a neurons activity. What is realistic about the IF model? What is unrealistic?\n6. Describe the roles of the IF model parameters `Vreset` and `Vthreshold`.\n7. Consider the IF model. Sketch voltage (V) versus time (t) for a small input current, for a large input current.\n    1. How does an increase in capacitance (C) impact the dynamics?\n    2. Can you interpret this physically?\n8. Plot the f-I curve for the IF model.\n\n---\n","srcMarkdownNoYaml":"\n\nIn this notebook we will use Python to simulate the leaky integrate and fire (LIF) neuron model.  We'll investigate, in particular, how the spiking activity varies as we adjust the input current $I$.\n\n#  Preliminaries\nBefore beginning, let's load in the Python package we'll need:\n\n```{pyodide-python}\nimport numpy as np\nimport matplotlib.pyplot as plt\n```\n\n#  Numerical solutions - Introduction\n\n \nHow do we compute a numerical solution to the integrate and fire model?\n  The basic idea is to rearrange the differential equation to get $V(t+1)$ on\n  the left hand side, and $V(t)$ on the right hand side.  Then, if we know\n  what's happening at time $t$, we can solve for what's happening at time $t+1$.\n\nFor example, consider the differential equation:\n\n$$\n  \\dfrac{dV}{dt} = -\\dfrac{V-V_*}{\\tau}\n$$\n\nIn words, we can think of:\n\n$dV$ as the \"change in voltage V\",\n\n$dt$ as the \"change in time t\".\n\nLet's consider the case that we record the voltage $V$ in discrete time steps. So\nwe observe:\n\n$V[0], V[1], V[2], \\ldots$\n\nat times:\n\n$dt, \\, 2*dt, \\, 3*dt, \\ldots$\n\nwhere $dt$ is the time between our samples of $V$.\n\nWe can now write the \"change in voltage V\" as:\n\n$$\n  dV = V(t+1) - V(t)\n$$\n\nNotice that the change in voltage is the difference in V between two\nsequential time samples.  Now, let's rewrite $\\dfrac{dV}{dt}$ as,\n\n$$\n  \\dfrac{dV}{dt} = \\dfrac{ V(t+1) - V(t) }{ dt } \n$$\n\nwhere we've replaced $dV$.  Now, let's substitute this expression into the equation at the top of this file:\n\n$$\n  \\dfrac{ V(t+1) - V(t) }{ dt } = \\dfrac{I}{C}.  \n$$\n\nSolving this equation for $V(t+1)$ you'll find  that:\n\n$$\n  V(t+1) = V(t) + dt*(-\\dfrac{V(t)-V_*}{\\tau})\n$$\n\nNotice that, in this expression, we use our current value of the voltage $V(t)$ and the model ($-\\dfrac{V(t)-V_*}{\\tau}$) to determine the next value of the voltage V(t+1).\n\nNow, let's program this equation in Python.  First, let's set the values\nfor the parameters $V_*$ and $\\tau$.\n\n```{pyodide-python}\nVstar=1.0\ntau  =1.0\n```\n\n  We also need to set the value for $dt$.  This defines the time step for our\n  model.  We must choose it small enough so that we don't miss anything\n  interesting.  We'll choose:\n\n```{pyodide-python}\ndt=0.01\n```\n\nLet's assume the units of time are seconds.  So, we step forward in time by $0.01$ s.\n\nThe right hand side of our equation is nearly defined, but we're still missing one thing, $V(t)$.\n\n::: {.callout}\n**Q:**  What value do we assign to $V(t)$?\n:::\n\nSo here's an easier question:  what *initial* value do we assign to $V(t)$?\n \n To start, we'll create an array of zeros to hold our results for $V$:\n\n```{pyodide-python}\nV = np.zeros([1000,1])\nnp.shape(V)\n```\n\nThis array `V` consists of 1000 rows and 1 column. We can think of each row entry as corresponding to a discrete step in time. Our goal is to fill-in the values of `V` (i.e., step forward in time), in a way consistent with our model.\n\nLet's choose an initial value for `V` of 0.2, which in our simple model we'll assume represents the rest state.\n\n```{pyodide-python}\nV[0]=0.2\n```\n\n::: {.callout}\n**Q:**  Given the initial state `V[0]=0.2`, calculate `V[1]`.  Then calcualte `V[2]`.\n:::\n\n  After the two calculations above, we've moved forward two time steps into\n  the future, from $t=0$ s to $t=0.01$ s, and then from $t=0.01$ s to $t=0.02$ s.  But what\n  if we want to know $V$ at $t=10$ s?  Then, this iteration-by-hand procedure becomes\n  much too boring and error-prone.  So, what do we do?  Let's make the\n  computer do it ...\n\n# Numerical solutions - Implementation\n\nLet's computerize this iteration-by-hand procedure to find `V[999]`.\n\nTo do so, we'll use a [for-loop](https://wiki.python.org/moin/ForLoop).\n\nHere's what it looks like:\n\n```{pyodide-python}\nfor k in range(1,999):\n    V[k+1] = V[k] + dt*(\"something\")\n```\n\n::: {.callout}\n**Q:**  Does this loop make sense?  Describe what's happening here. What is `something`?\n:::\n\n::: {.callout}\n**Q:**  Why does the `range` command end at `999`?\n:::\n\nExecute this for-loop and examine the results in vector `V`.  To do so, let's plot `V`:\n\n```{pyodide-python}\nplt.figure()\nplt.plot(V)\nplt.show()\n```\n\n::: {.callout}\n**Q:**  What happens to the voltage after 1000 steps?\n:::\n\n  This plot is informative, but not great.  Really, we'd like to plot the\n  voltage as a function of *time*, not steps or indices.  To do so, we\n  need to define a time axis:\n\n```{pyodide-python}\nt = np.arange(0,len(V))*dt\n```\n\n::: {.callout}\n**Q:**  What's happening in the command above?  Does it make sense?  (If not, trying printing or plotting `t`.)\n:::\n\nNow, with *time* defined, let's redo the plot of the voltage with the axes labeled appropriately.\n\n```{pyodide-python}\nplt.figure()\nplt.plot(t,V)\nplt.xlabel('Time [s]')\nplt.ylabel('V')\nplt.show()\n```\n\nFinally, let's put it all together . . .\n\n# LIF CODE (version 1)\n\n  So far, we constructed parts of the I&F model in bits-and-pieces.\n  Let's now collect all the code, compute a numerical solution to\n  the I&F model, and plot the results (with appropriate axes).\n\n```{pyodide-python}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nVstar   = 1                           #Set the parameter Vstar.\ntau  = 1                              #Set the parameter tau.\ndt  = 0.01                            #Set the timestep.\nV   = np.zeros([1000,1])              #Initialize V.\nV[0]= 0.2;                            #Set the initial value of V.\n\nfor k in range(1,999):                #March forward in time,\n    V[k+1] = V[k] + dt*(\"something\")  #... updating V along the way.\n\nt = np.arange(0,len(V))*dt            #Define the time axis.\n\nplt.figure()\nplt.plot(t,V)                         #Plot the results.\nplt.xlabel('Time [s]')\nplt.ylabel('Voltage [mV]')\nplt.show()\n```\n\n::: {.callout}\n**Q:**  Adjust the parameter `Vstar`.  What happens to `V` if `Vstar=0`?  Can you set `Vstar` so that `V` > 20 within 10 s?\n:::\n\n# Voltage threshold & reset\n\n  Notice, our model is missing something important:  **the reset**.\n\n::: {.callout}\n**Q:**  Without the reset, how does the voltage behave as $t\\rightarrow\\infty$ (if $Vstar>0$)?\n:::\n\n Now, let's update our model to include the reset.  To do so, we'll add two things to our code.\n  \n  - First, we'll define the voltage threshold `Vth`, and\n  reset voltage `Vreset`.\n  - Second, we'll check to see if `V` exceeds\n  `Vth` using an [if-statement](https://docs.python.org/3/tutorial/controlflow.html);  if it does, then we'll set `V` equal to\n  `Vreset`.\n\n::: {.callout}\n**Q:**  How will you update the code below to include the reset?\n:::\n\n```{pyodide-python}\nVth    =  25;     #Define the voltage threshold.\nVreset = -10;     #Define the reset voltage.\n\nfor k in range(1,999):                #March forward in time,\n    V[k+1] = V[k] + dt*(\"something\")  #... updating V along the way.\n    ### ADD SOMETHING HERE??? --------------------------\n```\n\n# I&F CODE (version 2)\n\nNow, let's put it all together to make a complete I&F model (with a thershold and reset), simulate it, and plot the result.\n\n```{pyodide-python}\n### ADD YOUR CODE!\n```\n\n::: {.callout}\n**Q:** Adjust the parameter `I`.  What happens to `V` if `I=10`?  If `I=100`?\n:::\n\n::: {.callout}\n**Q:** Adjust the parameter `C`.  What happens to `V` if `C=0.1`?  If `C=10`?\n:::\n\n::: {.callout}\n**Q:** What is \"spiking\" in this I&F model?\n:::\n\n---\n\n# Discussion\n\n1. Describe the main components of the **IF** model. Draw it (in some way).\n   \n3. Describe the main components of the **LIF** model. Draw it (in some way).\n4. Describe the differences and similarities between the IF and LIF models.\n5. The IF model is meant to mimic a neurons activity. What is realistic about the IF model? What is unrealistic?\n6. Describe the roles of the IF model parameters `Vreset` and `Vthreshold`.\n7. Consider the IF model. Sketch voltage (V) versus time (t) for a small input current, for a large input current.\n    1. How does an increase in capacitance (C) impact the dynamics?\n    2. Can you interpret this physically?\n8. Plot the f-I curve for the IF model.\n\n---\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"ignore":["Dont-Sync-2024"]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"number-sections":true,"filters":["pyodide"],"output-file":"LIF.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","theme":"cosmo","title":"Leaky Integrate and Fire Neuron","jupyter":"python 3"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
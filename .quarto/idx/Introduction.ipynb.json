{"title":"Introduction to Python for the practicing neuroscientist","markdown":{"yaml":{"title":"Introduction to Python for the practicing neuroscientist","project":{"type":"website"},"format":{"html":{"code-fold":true,"code-tools":true}},"jupyter":"python 3","number-sections":false,"filters":["pyodide"]},"headingText":"Starting Python","containsRefs":false,"markdown":"\n\nTo be frank:  this notebook is rather boring.  In this class, we will use the software package <a href=\"https://www.python.org/\" rel=\"external\">Python</a>. The best way to learn new software (and probably most things) is when motivated by a particular problem.  Would you read assembly instructions for furniture you do not plan to own?  Probably not. In other notebooks we will pursue specific questions driven by neuronal data, and use our desire to understand these data to motivate the development and application of computational methods.  But not in this notebook.  Here, we focus on basic coding techniques and principles in Python in the abstract, without motivation.  You - poor learner - must trust that these ideas and techniques will eventually be useful.  We begin by dipping our toe into the Python pool, and learning the basic strokes;  the fun and interesting parts in the \"real world\" of neuronal data happen later.\n\nLet us delay no further.  In the following examples, you are asked to execute code in Python.  If your Python experience is limited, you should actually *do* this, not just read the text below.  If you intend to ignore this advice - and not execute the code in Python - then instead walk to the local coffee shop, get a double espresso, and return to attempt these examples.\n\nThis notebook follows in spirit and sometimes in detail notebook 2 of <a href=\"https://www.elsevier.com/books/matlab-for-neuroscientists/wallisch/978-0-12-383836-0\" rel=\"external\">MATLAB for Neuroscientists</a>, an excellent reference for learning to use MATLAB in neuroscience with many additional examples.  If you have not used Python before, there are many excellent resources online (e.g., the <a href=\"https://jakevdp.github.io/PythonDataScienceHandbook/\" rel=\"external\">Python Data Science Handbook</a>).\n\n\nThere are two ways to interact with this notebook.  First, you could run it locally on your own computer using <a href=\"https://jupyter.org/\" rel=\"external\">Jupyter</a>. This is an excellent choice, because you'll be able to read, edit, and excute the Python code directly and you can save any changes you make or notes that you want to record.  The second way is to open this notebook in your browser and execute the examples directly in your browser, without installing additional software on your computer. In any case, we encourage you to execute each line of code in this file!\n\n::: {.callout-note}\nThroughout this notebook, we assume that you are running <a href=\"https://www.python.org/download/releases/3.0/\" rel=\"external\">Python 3</a>. Most of the functions used here are the same in Python 2 and 3. One noteable exception however is division. If you are using Python 2, you will find that the division operator `/` actually computes the *floor* of the division if both operands are integers (i.e., no decimal points). For example, in Python 2, `4/3` equals `1`. While, in Python 3, `4/3` equals `1.333`.\n\nWe encourage you to use Python 3 for the sake of compatibility with this notebook, as well as for compatibility with future releases of Python.\n:::\n\n### On-ramp: analysis of neural data in Python\nWe begin this notebook with an \"*on-ramp*\" to analysis in Python. The purpose of this on-ramp is to introduce you immediately to some aspects of Python. You may not understand all aspects of the Python language here, but that's not the point. Instead, the purpose of this on-ramp is to  illustrate what *can* be done. Our advice is to simply run the code below and see what happens...\n\n```{pyodide-python}\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\ndf = pd.read_csv(\"https://raw.githubusercontent.com/Mark-Kramer/BU-MA665-MA666/master/Data/Rhythms_1.csv\")\nd = np.array(df.iloc[:,0])\nt = np.array(df.iloc[:,1])\n\n# Print useful information about the data.\nprint(\"Sampling frequency is \" + str( 1/(t[2]-t[1]))  + ' Hz.')\nprint(\"Total duration of recording is \" + str(t[-1]) + ' s.')\nprint(\"Dimensions of data are \" + str(np.shape(d)) + ' data points.')\n\n# Choose an initial interval of time, from onset to 5 s,\ninitial_time_interval = t < 5        \n\n# ... and plot it.\nplt.plot(t[initial_time_interval], d[initial_time_interval])\nplt.xlabel('Time [s]')\nplt.ylabel('Data')\nplt.title('Initial interval of data');\nplt.show()\n```\n\n::: {.callout}\n**Q:** Try to read the code above. Can you see how it loads data, extracts useful information to print, then selects an interval of data to plot?\n\n**A:** If you've never used Python before, that's an especially difficult question. Please continue on to learn more!\n:::\n\n### Example 1: Python is a calculator\n\nExecute the following commands in Python:\n\n```{pyodide-python}\n4+9\n````\n\n```{pyodide-python}\n4/3\n````\n\n::: {.callout}\n**Q:**  What does Python return?  Does it make sense?\n::::\n\n### Example 2.  Python can compute complicated quantities.\n\nEnter the following command in Python:\n\n```{pyodide-python}\n4/10**2\n```\n\n::: {.callout}\n**Q:** Does this answer make sense?\n:::\n\n::: {.callout}\n**Q:** Can you use parentheses to change the answer?\n:::\n\n###  Example 3.  Python has useful built in functions.\n\nA function is a program that operates on arguments. Standard math functions and variables (and other useful things) can be accessed from the `math` and `numpy` modules. To use the `math` and `numpy` modules, we must first import both:\n\n```{pyodide-python}\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math\n```\n\n::: {.callout-note}\nIn this style, we indicate which module, or *namespace*, contains the function we want to call: `x = np.arange(10)` or `plt.plot(x, y)`.\n:::\n\nYou will often begin your data analysis with `import` statements, to load the functionality you need. We can now call functions from math using `numpy.*`.  For example,\n\n```{pyodide-python}\nnp.sin(2*np.pi)\n```\n\nAbove, `sin` is the sine function.  It operates on the argument `2*pi`.  Notice that, once we have imported the `numpy` module, Python knows the value of `pi`. Here's another example function that operates on arguments:\n\n```{pyodide-python}\nmath.atan(2*np.pi)\n```\n\n::: {.callout}\n**Q:**  What is `math.atan`?\n\n**A:** To answer this, try using Python Help.  To start the Python Help, simply put a `?` at the end of `math.atan` and then run this code block. \n:::\n\nYou should see a description of the function pop up at the bottom of the window.\n\n::: {.callout-note}\nPython Help is *extremely* useful, but may not work in a web browser.  You can always look there when you have questions about a function, or search the internet for help, i.e., <a href=\"http://www.google.com\" rel=\"external\">google it</a>.\n:::\n\n###  Example 4.  We can use Python to define lists of numbers.\n\nIn Python, there are several different data structures that are designed to store more than one element. Here we will focus on the `array` data structure, but if you are curious to know how and when to use other structures, there is a good explanation <a href='http://www.physics.nyu.edu/pine/pymanual/html/chap3/chap3_arrays.html'>here</a>. Let's define an array:\n\n```{pyodide-python}\nimport numpy as np\na = np.array([[1, 2, 3, 4]])\nprint(a)\n```\n\n###  Example 5.  We can manipulate arrays by scalars.\n\nA scalar is a single number.  Consider,\n\n```{pyodide-python}\na = np.array( [[1, 2, 3, 4]] )\nprint( a * 3 )\nprint( 4 * a )\nprint( a + 1 )\n```\n\n::: {.callout}    \n**Q:** What do you find?\n\n**A:** Notice that the scalar operates on each element of the array.\n:::\n\n###  Example 6.  We can manipulate arrays with arrays. \n\nLet's create an array and multiply it by itself,\n\n```{pyodide-python}\nimport numpy as np\na = np.array([1,2,3,4])\na * a\n```\n\n::: {.callout}\n**Q:**  What does this return?\n\n**A:** We see that the operator `*` performs element-by-element multiplication of the values in array `a`.\n:::\n\n### Example 7. More examples of manipulating arrays with arrays.\n\n```{pyodide-python}\nimport numpy as np\na = 2\nb = np.array( [[0, 4, 7, 6]] )\nc = np.array( [[1, 5, 6, 8]] )\n\nprint( b * c )\nprint( b / c + a)\nprint( np.multiply( b, c ))\n```\n\n::: {.callout}\n**Q:** What operation does `np.multiply()` perform?\n:::\n\n### Example 8.  We can probe the variables we've defined in Python.\n\nTo see a list of the variables you've defined, type `who` or `whos` in a code block by themselves. Notice `whos` provides more information.\n\n::: {.callout-note}\nThe functions `who` and `whos` can be *extremely* useful, but may not work in a web browser.\n:::\n\n### Example 9.  Determine the dimensions of an array\n\nTo examine the dimensions of an array, we can ask for the `shape`,\n\n```{pyodide-python}\na = np.array([[1,2,3,4]])\nprint(a.shape)\nprint(np.shape(a))\n```\n\nWe find that the shape of `a` is `(1,4)` or 1 row and 4 columns. Notice we have two options to execute the `shape` function:\n\n- In `a.shape` we return the attribute `shape` of the variable `a`. \n\n- In `np.shape(a)` we apply the function `shape` from `numpy` to the variable `a`.\n\nThe result is equivalent.\n\n### Example 10. Sometimes we need to reset the workspace\n\nBy doing so, we get rid of all the variables. To do so, type `%reset` and enter `y`\n\n::: {.callout}\n**Q.** What command could we use to confirm there are no variables in the workspace?\n\n**A.** Consider `who`.\n:::\n\n::: {.callout-note}   \nThe `%reset` command is an example of a *magic*. Magics are commands that start with the `%` symbol and use a language other than Python. They are only available in the notebook environment. In fact, the set of magics that is available is specific to the notebook kernel. This means that if you have a Jupyter notebook running a Ruby kernel the magics will be different.\n:::\n\n###  Example 11.  We can define matrices in Python.\nA matrix is an array with more than one dimensio.  Consider the following:\n\n```{pyodide-python}\nimport numpy as np\n\np = np.array( [[1,2,3],[4,5,6]] )\n```\n\nThis creates a matrix with two rows and three columns. Consider,\n\n```{pyodide-python}\nprint( p )\n```\n\n::: {.callout}\n**Q:** Can you see the two rows and three columns?\n:::\n\nWe can manipulate matrices like we manipulate vectors.\n\n```{pyodide-python}\nprint( p + 2 )\nprint( 2 * p )\nprint( p * p )\n```\n\n###  Example 12.  Indexing matrices and vectors.\nMatrices and vectors are arrays of numbers, and sometimes we want to\naccess individual elements or small subsets of these lists.  That's\neasy to do in Python.  Consider,\n\n```{pyodide-python}\nimport numpy as np\na = np.array( [1, 2, 3, 4, 5] )\nb = np.array( [6, 7, 8, 9, 10] )\n```\n\n Python indexes from 0 (like C, C++, Java, and unlike MATLAB and Fortran which start at 1). \n To access the 2nd element of `a` or `b`, type `a[1] / b[1]`.\n We'll be a bit fancier with our printing now to distinguish variables. \n Calling `str(a)` converts the variable `a` to a string that can be printed easily.\n Adding two strings just concatenates them: `\"hi\" + \" bye\" = \"hi bye\". `\n\n```{pyodide-python}\nprint( \"a[1] = \" + str(a[1]) )\nprint( \"b[1] = \" + str(b[1]) )\n```\n\n::: {.callout}    \n**Q.**  Do the results make sense?  How would you access the 4th element of each vector?\n:::\n\n  We can combine `a` and `b` to form a matrix with `a` as the first row and `b` as the second.\n  Note that we apply the function `array()` to the *list* `[a,b]`, which it converts to a matrix.\n\n```{pyodide-python}\nc = np.array([a,b])\nprint( \"c = \\n\" + str(c) )    # \\n is a newline, or carriage return, which makes the printed matrix lineup better \n```\n\n  To learn the size (or shape)\n of `c` we use `shape()`:\n\n```{pyodide-python}\nprint( \"shape of c = \" + str( np.shape(c) ) )\n```\n\n  The shape of `c` is `[2 5]`.  It has two rows and five columns.  To access\n  the individual element in the 1st row and 4th column of `c`, type `c[0,3]`\n\n```{pyodide-python}\nprint( \"c[0,3] = \" + str( c[0,3] ) )\n```\n\n<div class=\"python-note\">\n    \nWe access matrices using 'row, column' notation.  So `c[0,3]` means\nprint the element in row 0, column 3 of `c`.\n\n</div>\n\n::: {.callout}\n**Q.**  How would you print all rows in the 2nd column of `c`?\n:::\n\n###  Example 13:  We can find subsets of elements in matrices and vectors.\nOften we are interested in only some of the elements of a matrix or vector. For example, we might want to look at the data from a single experimental trial which is stored in a particular row of a matrix. Alternatively, we might want to find out when the values in a time series cross a given boundary. Doing this is simple in Python.\n\n#### Slicing\n*Slicing* means that we want to look at a specific portion of a vector or matrix, for example, the first row of a matrix. We will continue with the matrix `c` from the previous example. The notation '`:`' means '*all indices*'. To access all columns in the entire first row of `c`, type `c[0,:]`. To access the 2nd thru 4th columns of the first row of `c`, type `c[0,1:4]`.\n\n```{pyodide-python}\nprint( \"c[0,:] = \" + str( c[0,:] ) )\nprint( \"2nd through 4th columns of the first row are c[0,1:4] = \" + str(c[0,1:4]) )\n```\n\n  <div class=\"python-note\">\n    \n  The notation `1:4` means *all integers from 1 up to, but not including 4*, \n  which in this case gives columns 1, 2, and 3. \n  \n  </div>\n\nLeaving out the number before the colon tells Python to start at index 0. Leaving out the number after the colon tells Python to continue all the way to the end.\n\n```{pyodide-python}\nprint(\"c[0, :4] = \" + str( c[0,:4]))\nprint(\"c[0, 1:] = \" + str( c[0,1:]))\n```\n\nWe can also tell Python how to step through the indices. To access only the even columns of `c`, we can use the following:\n\n```{pyodide-python}\nc[0,::2]\n```\n\nThis code tells Python to start at 0, continue to the end, and step by 2. The result should be the values in row 0, columns 0, 2, and 4 of `c`. We could write this explicitly as `c[0,0:5:2]`.\n\n  #### Selecting elements that satisfy a condition\n  Sometimes we're interested in locating particular values within a\n  matrix or vector.  As an example, let's first define a vector.\n\n```{pyodide-python}\na = np.arange(1,10)    # this creates a vector of increasing values from 1 to 9\na = 2*a \n\nprint( \"a = \" + str(a) )\n```\n\n::: {.callout}\n**Q.**  Calculate the shape of `a`.  What is the maximum value of `a`? \n*Hint:* Use the `max()` function.\n:::\n\n  Now let's find all values in `a` that exceed 10.\n\n```{pyodide-python}\na[a > 10]\n```\n\nThis is called logical indexing, let's look at what `a>10` returns:\n\n```{pyodide-python}\nlgIdx = a > 10\nlgIdx\n```\n\nWhen we index `a` using this array `lgIdx` we get back only the entries \nin `a` corresponding to `True`, as above:\n\n```{pyodide-python}\na[lgIdx]\n```\n\nSometimes we want to know the actual indices in a where `a > 10`.\nWe can get them using the `nonzero()` array method, which returns the\nindex of all entries that were `True`, or non-zero.\n\n```{pyodide-python}\nlgIdx.nonzero()\n```\n\n<div class=\"python-note\">\n    \nThe command `nonzero()` can be used as both a *function* and a *method*. A method is called by adding it after the object it is meant to operate on with a period in between ( `lgIdx.nonzero()` ). A function is called with the *argument* explicitly provided inside the parentheses ( `nonzero(lgIdx)` ). Basically, a function and a method do the same thing, but a function needs to be given an argument, while a method assumes that the argument is the object that the method is attached to. Note that if we use `nonzero()` as a function, we need to tell it to look in NumPy for the definition (i.e. add `` at the beginning of the function call). \n\n</div>\n\nNow we have another way to select the desired elements of `a`:\n\n```{pyodide-python}\na[ (a > 10).nonzero() ]\n```\n\nWe can use these two types of indexing to change subsets of the values of `a`.\n\n```{pyodide-python}\nprint(\"a = \" + str(a))\na[a > 10] = 100\nprint(\"a = \" + str(a))\n```\n\n::: {.callout}\n**Q:** How does `a` change in the first and second print statements?\n:::\n\nWe can perform these same logical operations for a matrix,\n\n```{pyodide-python}\nb = np.array([[1,2,3],[4,5,6],[7,8,9]])\nprint( \"b = \\n\" + str(b) )\nprint( \" b > 5 is \\n\" + str(b > 5) )\nprint(\" b[b>5] is an array: \" + str(b[b>5]) )\n```\n\n<div class=\"python-note\">\n    \nNotice that the last line collapses the `True` entries to an array, \nordered by row and then by column. If you've used MATLAB, this is \nthe opposite of what it does!\n\n</div>\n\n###  Example 14:  Plotting data in Python.\nIt's not easy to look at lists of numbers and gain an intuitive\nfeeling for their behavior, especially when the lists are long.  In\nthese cases, it's better to visualize the lists of numbers by\nplotting them.  Consider\n\n```{pyodide-python}\nimport numpy as np\n\nx = np.linspace(0,10,11)   \nprint( \"x = \" + str(x) )\n\n#   The above line constructs a vector that starts at 0, ends at 10, and\n#   has 11 entries (takes steps of size 1 from 0 to 10). Let\n\ny = np.sin(x)\nprint( \"y = \" + str(y) )\n```\n\n::: {.callout}\n**Q.** Looking at the values in 'y' printed above, can you tell what's happending?\n\n**A.** Not really ... let's visualize `y` vs `x` instead.\n:::\n\n#### matplotlib\nTo visualize `y` versus `x` let's plot it. To do so, let's first import some basic plotting routines from `matplotlib`, which provides a nice <a href=\"https://matplotlib.org/\" rel=\"external\">2D plotting library</a>. We'll also tell Python to show  `matplotlib` graphics inline, in this notebook.\n\nLet's start by plotting a simple example for `x` and `y`,\n\n```{pyodide-python}\nimport matplotlib.pyplot as plt\nx = ([1, 2, 3, 4])\ny = x\nplt.figure()\nplt.plot(x,y) \nplt.show()          # this is the plotting equivalent of print()\n```\n\n::: {.callout}\n**Q.** Does the plot above make sense for the variables `x` and `y`?\n:::\n\nNow, let's go back to the definitions of `x` and `y` that we started this example with and plot `y` versus `x`.\n\n```{pyodide-python}\nx = np.linspace(0,10,11)   \ny = np.sin(x)\n\nplt.figure()\nplt.plot(x, y)\nplt.show()\n```\n\n The plot of `x` versus `y` should look a bit jagged, and not \n smooth like a sinusoid.  To make the curve smoother,\n let's redefine `x` as,\n\n```{pyodide-python}\nimport numpy as np\nx = np.linspace(0,10, 101)\nprint(x)\n```\n\n::: {.callout}\n**Q.**  Compare this definition of `x` to the definition above.  How do these\ntwo definitions differ?\n:::\n\n::: {.callout}    \n**Q.**  What is the size of `x`?  Does this make sense?\n:::\n\nNow let's replot the sine function.\n\n```{pyodide-python}\ny = np.sin(x)\nplt.figure()\nplt.plot(x,y,'k')   # the 'k' we've added makes the curve black instead of blue\nplt.show()\n```\n\n::: {.callout}\n**Q.** Does this plot make sense, given your knowledge of `x`, `y`, and trigonometry?\n:::\n\n### Example 15: What if we want to compare several functions?\n\nContinuing the example in the previous section, let’s define a second vector\n\n```{pyodide-python}\nimport numpy as np\nx = np.linspace(0,10, 101)\nz = np.cos(x)\n```\n\nand plot it:\n\n```{pyodide-python}\nimport matplotlib.pyplot as plt\nplt.figure()\nplt.plot(x,z)\nplt.show()\n```\n\nWe’d now like to compare the two variables `y` and `z`. To do this, let’s plot both vectors on\nthe same figure, label the axes, and provide a legend,\n\n```{pyodide-python}\ny = np.sin(x)\nplt.figure()\nplt.plot(x,z)                     # plot z vs x.\nplt.plot(x,y,'r')                 # plot y vs x in red\nplt.show()\n```\n\nNotice that we’ve included a third input to the function `plot`. Here the third input tells Python to draw the curve in a particular color: `'r'` for red. There are many options we can use to plot; to see more, check out the documentation for <a href=\"https://matplotlib.org/api/_as_gen/matplotlib.pyplot.plot.html\" rel=\"external\">plot</a>.\n\nWe can also label the axes, give the figure a title, and provide a legend,\n\n```{pyodide-python}\nplt.figure()\nplt.plot(x,z)                     # plot z vs x\nplt.plot(x,y,'r')                 # plot y vs x in red\nplt.xlabel('x')                   # x-axis label\nplt.ylabel('y or z')              # y-axis label\nplt.title('y vs x and z vs x')    # title\nplt.legend(('y','z'))             # make a legend labeling each line\nplt.show()\n```\n\nTo futher edit this plot, you might decide - for example - that the font size for the labels is too small. We can change the default with:\n\n```{pyodide-python}\nplt.figure()\nplt.plot(x,y, label='y')     # sometimes it is easier to name a trace within the plot() call\nplt.plot(x,z, label='z')     # notice without a color matplotlib will assign one\nplt.xlabel('x', fontsize=14)\nplt.ylabel('y', fontsize=14)\nplt.title('y vs x', fontsize=18)\nplt.legend(fontsize=12)\nplt.show()\n```\n\n###  Example 16:  We can make random numbers in Python.\nTo generate a single Gaussian random number in Python, use the function in the NumPy `random` module.\n\n```{pyodide-python}\nimport numpy as np\n\nprint(\"a Gaussian random number (mean=0, variance=1): \" + str( np.random.randn() ))\n\n# a uniform random number on [0,1)\nprint(\"a uniform random number from [0,1): \" + str(np.random.rand()))\n```\n\nLet's generate a vector of 1000 Gaussian random numbers:\n\n```{pyodide-python}\nr = np.random.randn(1000)\n```\n\n... and look at a histogram of the vector:\n\n```{pyodide-python}\nimport matplotlib.pyplot as plt\nplt.figure()\nplt.hist(r)\nplt.show()\n```\n\n::: {.callout}\n**Q.** Does this histogram make sense? Is it what you expect for a distribution of Gaussian random variables?\n:::\n\n<div class=\"python-note\">\n    \nSee Python Help (`hist?`) to learn about the function `hist()`.\n\n</div>\n\n###  Example 17: Sampling randomly from a vector (courtsey of [vgascue](https://github.com/vgascue))\n\nUsing the random module from numpy one can also take a random sample from a vector. \nLet's take 5 random samples from the vector \"r\" generated in example 16.\n\n```{pyodide-python}\nimport numpy as np\nsample = np.random.choice(r, size=5)\nprint(\"5 random samples from vector r : \" + str(sample))\n```\n\nTry running it more the one time to see how the output changes!\n\n###  Example 18:  Repeating commands over and over and over . . . \n  Sometimes we'll want to repeat the same command over and over again.\n  For example, what if we want to plot `sin(x + k*pi/4)` where `k` varies from 1 to 5 in\n  steps of 1;  how do we do it?  Consider the following:\n\n```{pyodide-python}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.arange(0,10,0.1) # Define a vector x that ranges from 0 to 9.9 with step 0.1.\nk = 1                # Fix k=1,\ny = np.sin(x + k*np.pi/4)  # ... and define y at this k.\n\nplt.figure()               # Make a new figure,\nplt.plot(x,y)              # ... and plot y versus x.\n\nk = 2                # Let's repeat this, for k=2,\ny = np.sin(x + k*np.pi/4)  # ... and redefine y at this k,\nplt.plot(x,y)              # ... and plot it.\n\nk = 3                      # Let's repeat this, for k=3,\ny = np.sin(x + k*np.pi/4)  # ... and redefine y at this k,\nplt.plot(x,y)              # ... and plot it.\n\nk = 4                      # Let's repeat this, for k=4,\ny = np.sin(x + k*np.pi/4)  # ... and redefine y at this k,\nplt.plot(x,y)              # ... and plot it.\n\nk = 5                      # Let's repeat this, for k=5,\ny = np.sin(x + k*np.pi/4)  # ... and redefine y at this k,\nplt.plot(x,y)              # ... and plot it.\n\nplt.show()\n```\n\nThat's horrible code!  All I did was cut and paste the same thing four times.  As a general rule, if you're repeatedly cutting and pasting in code, what you're doing is inefficient and typically error prone.  There's a much more elegant way to do this, and it involves making a `for` loop.  Consider:\n\n```{pyodide-python}\nx = np.arange(0,10,0.1)     #First, define the vector x.\n```\n\nNow let's declare a `for` loop where `k` successively takes the values 1, then 2, then 3, ..., up to 5. Note, any code we want to execute as part of the loop must be indented one level. The first line of code that is not indented, in this case `show()` below, executes after the for loop completes\n\n```{pyodide-python}\nplt.figure()\nfor k in range(1,6):               \n    y = np.sin(x + k*np.pi/4) #Define y (note the variable 'k' in sin), also note we have indented here!\n    plt.plot(x,y)             #Plot y versus x\n     \n# no indentation now, so this code follows the loop\nplt.show()\n```\n\nThe small section of code above replaces all the cutting-and-pasting.\n  Instead of cutting and pasting, we update the definition of `y` with different values of `k` and plot it within this for-loop.\n\n::: {.callout}\n**Q.**  Spend some time studying this for-loop.  Does it make sense?\n:::\n\n::: {.callout-note}   \n**Important:** Python uses **indentation** to define `for` loops.\n:::\n\n###  Example 19:  Defining a new function.\nWe've spent some time in this notebook writing and executing code. Sometimes we'll need to write our own Python functions.  Let's do that now.\n\nOur function will do something very simple: it will take as input a\nvector and return as output the vector elements squared plus an additive\nconstant.\n\nIf have a vector, `v`, and a constant, `b`, we would like to call:\n\n    vsq = my_square_function(v, b)\n    \nThis won't work!  We first need to define `my_square_function`. Let's do so now,\n\n```{pyodide-python}\ndef my_square_function(x, c):\n    \"\"\"Square a vector and add a constant.\n\n    Arguments:\n    x -- vector to square\n    c -- constant to add to the square of x\n    \n    Returns:\n    x*x + c\n    \"\"\"\n    \n    return x * x + c\n```\n\nThe function begins with the keyword `def` followed by the function name and the inputs in parentheses. Notice that this first line ends with a colon `:`. All of the function components that follow this first line should be **indented one level**. This is just like the `for` loop we applied earlier; the operations performed by the for loop were indented one leve.\n\n<div class=\"python-note\">\n    \nWhen defining the function, the code the function executes should be indented one level.\n\n</div>\n\nThe text inside triple quotes provides an optional documentation string that describes our function. While optional, including a '*doc string*' is an important part of making your code understandable and reuseable.\n\nThe keyword `return` exits the function, and in this case returns the expression `x * x + c`. Note that a return statement with no arguments returns `None`, indicating the absence of a value.\n\nWith the function defined, let's now call it. To do so we first define the inputs, and then run the function, as follows:\n\n```{pyodide-python}\nimport numpy as np\nv = np.linspace(0.,10.,11)\nb = 2.5\n\n# Now let's run the code,\nv2 = my_square_function(v, b)\nprint(\"v = \" + str(v))\nprint(\"v*v+2.5 = \" + str(v2))\n```\n\n::: {.callout}\n**Q.** Try to make a function, my_power, so that \n`y = power(x,n)` evaluates $y = x^n$, \n(in Python you can use `x**n` to take the power)\n:::\n\n### Example 20: Load  data into Python\nFor our last example let's load a data file on the web in the `.csv` format into Python.\n\nTo do so, let's first import the `pandas` module,\n\n```{pyodide-python}\nimport pandas as pd\n```\n\nNow, let's load a data file using the function `read_csv`,\n\n```{pyodide-python}\ndf = pd.read_csv(\"https://raw.githubusercontent.com/Mark-Kramer/BU-MA665-MA666/master/Data/Rhythms_1.csv\")\ndf.info()\n```\n\nThe variable `df` that holds the loaded data is a Python [DataFrame](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html). We can think of it as a simple table that holds our data.\n\nLet's print it,\n\n```{pyodide-python}\nprint(df)\n```\n\nWe see that the columns in the dataframe consist of two variables: `d` and `t`. Our collaborator who provided the data tells us that these correspond to the voltage recording (`d`) and a time axis (`t`) for her data.\n\nLet's define variables to hold the data corresponding to each key,\n\n```{pyodide-python}\nimport numpy as np\nd = np.array(df.iloc[:,0])  #Get the values associated with the first column of the dataframe\nt = np.array(df.iloc[:,1])  #Get the values associated with the first column of the dataframe\n```\n\n::: {.callout-note}\nHere we convert the data in each column to a numpy array, because we'd (probably) like numpy to function on these values.\n:::\n\nNow, let's plot the LFP data versus the time axis,\n\n```{pyodide-python}\nimport matplotlib.pyplot as plt\n\n# Choose a subset to plot\nt = t[0:500]\nd = d[0:500]\n\nplt.figure()\nplt.plot(t, d)\nplt.title('My plot')\nplt.xlabel('Time [s]')\nplt.ylabel('Voltage [mV]')\nplt.show()\n```\n\n### Example 21: Compute statistics and compare (courtesy of [mateouma](https://github.com/mateouma))\n\n\nLet's do some statistics. First, our standard imports.\n\n```{pyodide-python}\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n```\n\nWith numpy, we can find the mean and standard deviation of our LFP data.\n\n```{pyodide-python}\nmu = np.mean(d)\nsd = np.std(d)\n```\n\nNow, let's use numpy to randomly generate numbers according to a normal distribution with the same mean and standard deviation as the LFP data. The syntax is `np.random.normal(mean, sd, size)`, where `mean`, `sd`, and `size` are variables or numbers.\n\n```{pyodide-python}\nsamps = np.random.normal(mu, sd, 500)\n```\n\nWe can use a histogram to compare the distribution of the data with a normal distribution with the same mean and standard deviation.\n\n```{pyodide-python}\nplt.figure()\nplt.hist(samps)\nplt.hist(d)\nplt.show()\n```\n\nAs we can see, our data doesn't look normally distributed, but in practice we should use a statistical test to make this assessment.\n\n### Example 22: Recursion (courtsey of [marieshi](https://github.com/marieshi))\n\nLet's consider a classic mathematical sequence: the [Fibonacci sequence](https://en.wikipedia.org/wiki/Fibonacci_sequence). This is a sequence that starts with 0 and 1, and each number is the sum of the preceding two numbers in the sequence.\n\nLet's use this sequence to expand our knowledge of functions.\n\nWe use recursive functions when we want to call the function itself within the function.\n\n```{pyodide-python}\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n```\n\n```{pyodide-python}\n\ndef Fib(n):\n    #First establish base cases, or cases that are pre-defined by the question.\n    if n<= 0:\n        print(\"Incorrect input\")\n    # First Fibonacci number is 0\n    elif n == 1:\n        return 0\n    # Second Fibonacci number is 1\n    elif n == 2:\n        return 1\n    else:\n        return Fib(n-1)+Fib(n-2)\n```\n\n```{pyodide-python}\nFib(20)\n```\n\nWe can think of recursive functions algorithmically: it usually starts with one or more base cases, or the simplest form of the function. This defines the behavior and serve as an anchor. \n\nNext are the recursive calls, which simplifies the problem iteratively, usually by calling the function back onto itself.\n\n::: {.callout}\n**Q.** What is the difference between using recursion and loops in this case? Do you see any benefits? \n:::\n\nRecursion tends to be most functional when analyzing tree or nested structures.\n\nFor example, if you are writing code and have a lot of parantheses you can't keep track of, we can use recursion to see if they are balanced.\n\nTo keep this a bit simpler, let's pretend that you have extracted all the parantheses and just need to check if a string of open or closed parantheses are balanced.\n\nFor example, () is balanced, )))((( or (() are not. \n\n```{pyodide-python}\ndef is_balanced(s):\n    # If string is empty, it's balanced\n    if not s:\n        return True\n    \n    # If the first character is a closing parenthesis, it's unbalanced\n    if s[0] == ')':\n        return False\n    \n    # Recursive step: Find the matching closing parenthesis for the first opening parenthesis\n    else:\n        balance = 0\n        # If the parentheses are balanced, there should be equal closing and opening parantheses. This will be represented by balance=0\n        for i in range(len(s)):\n            if s[i] == '(':\n                balance += 1\n            elif s[i] == ')':\n                balance -= 1\n            \n            if balance == 0:\n                # Recursively check the substring inside the matched pair\n                # and the substring after the matched pair\n                return is_balanced(s[1:i]) and is_balanced(s[i+1:])\n        \n        # if balance !=0, not balanced.\n        return False\n    \n```\n\nLet's test our function out!\n\n```{pyodide-python}\nprint(is_balanced(\"(()())\")) \n```\n\n```{pyodide-python}\nprint(is_balanced(\"())\"))\n```\n","srcMarkdownNoYaml":"\n\nTo be frank:  this notebook is rather boring.  In this class, we will use the software package <a href=\"https://www.python.org/\" rel=\"external\">Python</a>. The best way to learn new software (and probably most things) is when motivated by a particular problem.  Would you read assembly instructions for furniture you do not plan to own?  Probably not. In other notebooks we will pursue specific questions driven by neuronal data, and use our desire to understand these data to motivate the development and application of computational methods.  But not in this notebook.  Here, we focus on basic coding techniques and principles in Python in the abstract, without motivation.  You - poor learner - must trust that these ideas and techniques will eventually be useful.  We begin by dipping our toe into the Python pool, and learning the basic strokes;  the fun and interesting parts in the \"real world\" of neuronal data happen later.\n\nLet us delay no further.  In the following examples, you are asked to execute code in Python.  If your Python experience is limited, you should actually *do* this, not just read the text below.  If you intend to ignore this advice - and not execute the code in Python - then instead walk to the local coffee shop, get a double espresso, and return to attempt these examples.\n\nThis notebook follows in spirit and sometimes in detail notebook 2 of <a href=\"https://www.elsevier.com/books/matlab-for-neuroscientists/wallisch/978-0-12-383836-0\" rel=\"external\">MATLAB for Neuroscientists</a>, an excellent reference for learning to use MATLAB in neuroscience with many additional examples.  If you have not used Python before, there are many excellent resources online (e.g., the <a href=\"https://jakevdp.github.io/PythonDataScienceHandbook/\" rel=\"external\">Python Data Science Handbook</a>).\n\n### Starting Python\n\nThere are two ways to interact with this notebook.  First, you could run it locally on your own computer using <a href=\"https://jupyter.org/\" rel=\"external\">Jupyter</a>. This is an excellent choice, because you'll be able to read, edit, and excute the Python code directly and you can save any changes you make or notes that you want to record.  The second way is to open this notebook in your browser and execute the examples directly in your browser, without installing additional software on your computer. In any case, we encourage you to execute each line of code in this file!\n\n::: {.callout-note}\nThroughout this notebook, we assume that you are running <a href=\"https://www.python.org/download/releases/3.0/\" rel=\"external\">Python 3</a>. Most of the functions used here are the same in Python 2 and 3. One noteable exception however is division. If you are using Python 2, you will find that the division operator `/` actually computes the *floor* of the division if both operands are integers (i.e., no decimal points). For example, in Python 2, `4/3` equals `1`. While, in Python 3, `4/3` equals `1.333`.\n\nWe encourage you to use Python 3 for the sake of compatibility with this notebook, as well as for compatibility with future releases of Python.\n:::\n\n### On-ramp: analysis of neural data in Python\nWe begin this notebook with an \"*on-ramp*\" to analysis in Python. The purpose of this on-ramp is to introduce you immediately to some aspects of Python. You may not understand all aspects of the Python language here, but that's not the point. Instead, the purpose of this on-ramp is to  illustrate what *can* be done. Our advice is to simply run the code below and see what happens...\n\n```{pyodide-python}\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\ndf = pd.read_csv(\"https://raw.githubusercontent.com/Mark-Kramer/BU-MA665-MA666/master/Data/Rhythms_1.csv\")\nd = np.array(df.iloc[:,0])\nt = np.array(df.iloc[:,1])\n\n# Print useful information about the data.\nprint(\"Sampling frequency is \" + str( 1/(t[2]-t[1]))  + ' Hz.')\nprint(\"Total duration of recording is \" + str(t[-1]) + ' s.')\nprint(\"Dimensions of data are \" + str(np.shape(d)) + ' data points.')\n\n# Choose an initial interval of time, from onset to 5 s,\ninitial_time_interval = t < 5        \n\n# ... and plot it.\nplt.plot(t[initial_time_interval], d[initial_time_interval])\nplt.xlabel('Time [s]')\nplt.ylabel('Data')\nplt.title('Initial interval of data');\nplt.show()\n```\n\n::: {.callout}\n**Q:** Try to read the code above. Can you see how it loads data, extracts useful information to print, then selects an interval of data to plot?\n\n**A:** If you've never used Python before, that's an especially difficult question. Please continue on to learn more!\n:::\n\n### Example 1: Python is a calculator\n\nExecute the following commands in Python:\n\n```{pyodide-python}\n4+9\n````\n\n```{pyodide-python}\n4/3\n````\n\n::: {.callout}\n**Q:**  What does Python return?  Does it make sense?\n::::\n\n### Example 2.  Python can compute complicated quantities.\n\nEnter the following command in Python:\n\n```{pyodide-python}\n4/10**2\n```\n\n::: {.callout}\n**Q:** Does this answer make sense?\n:::\n\n::: {.callout}\n**Q:** Can you use parentheses to change the answer?\n:::\n\n###  Example 3.  Python has useful built in functions.\n\nA function is a program that operates on arguments. Standard math functions and variables (and other useful things) can be accessed from the `math` and `numpy` modules. To use the `math` and `numpy` modules, we must first import both:\n\n```{pyodide-python}\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math\n```\n\n::: {.callout-note}\nIn this style, we indicate which module, or *namespace*, contains the function we want to call: `x = np.arange(10)` or `plt.plot(x, y)`.\n:::\n\nYou will often begin your data analysis with `import` statements, to load the functionality you need. We can now call functions from math using `numpy.*`.  For example,\n\n```{pyodide-python}\nnp.sin(2*np.pi)\n```\n\nAbove, `sin` is the sine function.  It operates on the argument `2*pi`.  Notice that, once we have imported the `numpy` module, Python knows the value of `pi`. Here's another example function that operates on arguments:\n\n```{pyodide-python}\nmath.atan(2*np.pi)\n```\n\n::: {.callout}\n**Q:**  What is `math.atan`?\n\n**A:** To answer this, try using Python Help.  To start the Python Help, simply put a `?` at the end of `math.atan` and then run this code block. \n:::\n\nYou should see a description of the function pop up at the bottom of the window.\n\n::: {.callout-note}\nPython Help is *extremely* useful, but may not work in a web browser.  You can always look there when you have questions about a function, or search the internet for help, i.e., <a href=\"http://www.google.com\" rel=\"external\">google it</a>.\n:::\n\n###  Example 4.  We can use Python to define lists of numbers.\n\nIn Python, there are several different data structures that are designed to store more than one element. Here we will focus on the `array` data structure, but if you are curious to know how and when to use other structures, there is a good explanation <a href='http://www.physics.nyu.edu/pine/pymanual/html/chap3/chap3_arrays.html'>here</a>. Let's define an array:\n\n```{pyodide-python}\nimport numpy as np\na = np.array([[1, 2, 3, 4]])\nprint(a)\n```\n\n###  Example 5.  We can manipulate arrays by scalars.\n\nA scalar is a single number.  Consider,\n\n```{pyodide-python}\na = np.array( [[1, 2, 3, 4]] )\nprint( a * 3 )\nprint( 4 * a )\nprint( a + 1 )\n```\n\n::: {.callout}    \n**Q:** What do you find?\n\n**A:** Notice that the scalar operates on each element of the array.\n:::\n\n###  Example 6.  We can manipulate arrays with arrays. \n\nLet's create an array and multiply it by itself,\n\n```{pyodide-python}\nimport numpy as np\na = np.array([1,2,3,4])\na * a\n```\n\n::: {.callout}\n**Q:**  What does this return?\n\n**A:** We see that the operator `*` performs element-by-element multiplication of the values in array `a`.\n:::\n\n### Example 7. More examples of manipulating arrays with arrays.\n\n```{pyodide-python}\nimport numpy as np\na = 2\nb = np.array( [[0, 4, 7, 6]] )\nc = np.array( [[1, 5, 6, 8]] )\n\nprint( b * c )\nprint( b / c + a)\nprint( np.multiply( b, c ))\n```\n\n::: {.callout}\n**Q:** What operation does `np.multiply()` perform?\n:::\n\n### Example 8.  We can probe the variables we've defined in Python.\n\nTo see a list of the variables you've defined, type `who` or `whos` in a code block by themselves. Notice `whos` provides more information.\n\n::: {.callout-note}\nThe functions `who` and `whos` can be *extremely* useful, but may not work in a web browser.\n:::\n\n### Example 9.  Determine the dimensions of an array\n\nTo examine the dimensions of an array, we can ask for the `shape`,\n\n```{pyodide-python}\na = np.array([[1,2,3,4]])\nprint(a.shape)\nprint(np.shape(a))\n```\n\nWe find that the shape of `a` is `(1,4)` or 1 row and 4 columns. Notice we have two options to execute the `shape` function:\n\n- In `a.shape` we return the attribute `shape` of the variable `a`. \n\n- In `np.shape(a)` we apply the function `shape` from `numpy` to the variable `a`.\n\nThe result is equivalent.\n\n### Example 10. Sometimes we need to reset the workspace\n\nBy doing so, we get rid of all the variables. To do so, type `%reset` and enter `y`\n\n::: {.callout}\n**Q.** What command could we use to confirm there are no variables in the workspace?\n\n**A.** Consider `who`.\n:::\n\n::: {.callout-note}   \nThe `%reset` command is an example of a *magic*. Magics are commands that start with the `%` symbol and use a language other than Python. They are only available in the notebook environment. In fact, the set of magics that is available is specific to the notebook kernel. This means that if you have a Jupyter notebook running a Ruby kernel the magics will be different.\n:::\n\n###  Example 11.  We can define matrices in Python.\nA matrix is an array with more than one dimensio.  Consider the following:\n\n```{pyodide-python}\nimport numpy as np\n\np = np.array( [[1,2,3],[4,5,6]] )\n```\n\nThis creates a matrix with two rows and three columns. Consider,\n\n```{pyodide-python}\nprint( p )\n```\n\n::: {.callout}\n**Q:** Can you see the two rows and three columns?\n:::\n\nWe can manipulate matrices like we manipulate vectors.\n\n```{pyodide-python}\nprint( p + 2 )\nprint( 2 * p )\nprint( p * p )\n```\n\n###  Example 12.  Indexing matrices and vectors.\nMatrices and vectors are arrays of numbers, and sometimes we want to\naccess individual elements or small subsets of these lists.  That's\neasy to do in Python.  Consider,\n\n```{pyodide-python}\nimport numpy as np\na = np.array( [1, 2, 3, 4, 5] )\nb = np.array( [6, 7, 8, 9, 10] )\n```\n\n Python indexes from 0 (like C, C++, Java, and unlike MATLAB and Fortran which start at 1). \n To access the 2nd element of `a` or `b`, type `a[1] / b[1]`.\n We'll be a bit fancier with our printing now to distinguish variables. \n Calling `str(a)` converts the variable `a` to a string that can be printed easily.\n Adding two strings just concatenates them: `\"hi\" + \" bye\" = \"hi bye\". `\n\n```{pyodide-python}\nprint( \"a[1] = \" + str(a[1]) )\nprint( \"b[1] = \" + str(b[1]) )\n```\n\n::: {.callout}    \n**Q.**  Do the results make sense?  How would you access the 4th element of each vector?\n:::\n\n  We can combine `a` and `b` to form a matrix with `a` as the first row and `b` as the second.\n  Note that we apply the function `array()` to the *list* `[a,b]`, which it converts to a matrix.\n\n```{pyodide-python}\nc = np.array([a,b])\nprint( \"c = \\n\" + str(c) )    # \\n is a newline, or carriage return, which makes the printed matrix lineup better \n```\n\n  To learn the size (or shape)\n of `c` we use `shape()`:\n\n```{pyodide-python}\nprint( \"shape of c = \" + str( np.shape(c) ) )\n```\n\n  The shape of `c` is `[2 5]`.  It has two rows and five columns.  To access\n  the individual element in the 1st row and 4th column of `c`, type `c[0,3]`\n\n```{pyodide-python}\nprint( \"c[0,3] = \" + str( c[0,3] ) )\n```\n\n<div class=\"python-note\">\n    \nWe access matrices using 'row, column' notation.  So `c[0,3]` means\nprint the element in row 0, column 3 of `c`.\n\n</div>\n\n::: {.callout}\n**Q.**  How would you print all rows in the 2nd column of `c`?\n:::\n\n###  Example 13:  We can find subsets of elements in matrices and vectors.\nOften we are interested in only some of the elements of a matrix or vector. For example, we might want to look at the data from a single experimental trial which is stored in a particular row of a matrix. Alternatively, we might want to find out when the values in a time series cross a given boundary. Doing this is simple in Python.\n\n#### Slicing\n*Slicing* means that we want to look at a specific portion of a vector or matrix, for example, the first row of a matrix. We will continue with the matrix `c` from the previous example. The notation '`:`' means '*all indices*'. To access all columns in the entire first row of `c`, type `c[0,:]`. To access the 2nd thru 4th columns of the first row of `c`, type `c[0,1:4]`.\n\n```{pyodide-python}\nprint( \"c[0,:] = \" + str( c[0,:] ) )\nprint( \"2nd through 4th columns of the first row are c[0,1:4] = \" + str(c[0,1:4]) )\n```\n\n  <div class=\"python-note\">\n    \n  The notation `1:4` means *all integers from 1 up to, but not including 4*, \n  which in this case gives columns 1, 2, and 3. \n  \n  </div>\n\nLeaving out the number before the colon tells Python to start at index 0. Leaving out the number after the colon tells Python to continue all the way to the end.\n\n```{pyodide-python}\nprint(\"c[0, :4] = \" + str( c[0,:4]))\nprint(\"c[0, 1:] = \" + str( c[0,1:]))\n```\n\nWe can also tell Python how to step through the indices. To access only the even columns of `c`, we can use the following:\n\n```{pyodide-python}\nc[0,::2]\n```\n\nThis code tells Python to start at 0, continue to the end, and step by 2. The result should be the values in row 0, columns 0, 2, and 4 of `c`. We could write this explicitly as `c[0,0:5:2]`.\n\n  #### Selecting elements that satisfy a condition\n  Sometimes we're interested in locating particular values within a\n  matrix or vector.  As an example, let's first define a vector.\n\n```{pyodide-python}\na = np.arange(1,10)    # this creates a vector of increasing values from 1 to 9\na = 2*a \n\nprint( \"a = \" + str(a) )\n```\n\n::: {.callout}\n**Q.**  Calculate the shape of `a`.  What is the maximum value of `a`? \n*Hint:* Use the `max()` function.\n:::\n\n  Now let's find all values in `a` that exceed 10.\n\n```{pyodide-python}\na[a > 10]\n```\n\nThis is called logical indexing, let's look at what `a>10` returns:\n\n```{pyodide-python}\nlgIdx = a > 10\nlgIdx\n```\n\nWhen we index `a` using this array `lgIdx` we get back only the entries \nin `a` corresponding to `True`, as above:\n\n```{pyodide-python}\na[lgIdx]\n```\n\nSometimes we want to know the actual indices in a where `a > 10`.\nWe can get them using the `nonzero()` array method, which returns the\nindex of all entries that were `True`, or non-zero.\n\n```{pyodide-python}\nlgIdx.nonzero()\n```\n\n<div class=\"python-note\">\n    \nThe command `nonzero()` can be used as both a *function* and a *method*. A method is called by adding it after the object it is meant to operate on with a period in between ( `lgIdx.nonzero()` ). A function is called with the *argument* explicitly provided inside the parentheses ( `nonzero(lgIdx)` ). Basically, a function and a method do the same thing, but a function needs to be given an argument, while a method assumes that the argument is the object that the method is attached to. Note that if we use `nonzero()` as a function, we need to tell it to look in NumPy for the definition (i.e. add `` at the beginning of the function call). \n\n</div>\n\nNow we have another way to select the desired elements of `a`:\n\n```{pyodide-python}\na[ (a > 10).nonzero() ]\n```\n\nWe can use these two types of indexing to change subsets of the values of `a`.\n\n```{pyodide-python}\nprint(\"a = \" + str(a))\na[a > 10] = 100\nprint(\"a = \" + str(a))\n```\n\n::: {.callout}\n**Q:** How does `a` change in the first and second print statements?\n:::\n\nWe can perform these same logical operations for a matrix,\n\n```{pyodide-python}\nb = np.array([[1,2,3],[4,5,6],[7,8,9]])\nprint( \"b = \\n\" + str(b) )\nprint( \" b > 5 is \\n\" + str(b > 5) )\nprint(\" b[b>5] is an array: \" + str(b[b>5]) )\n```\n\n<div class=\"python-note\">\n    \nNotice that the last line collapses the `True` entries to an array, \nordered by row and then by column. If you've used MATLAB, this is \nthe opposite of what it does!\n\n</div>\n\n###  Example 14:  Plotting data in Python.\nIt's not easy to look at lists of numbers and gain an intuitive\nfeeling for their behavior, especially when the lists are long.  In\nthese cases, it's better to visualize the lists of numbers by\nplotting them.  Consider\n\n```{pyodide-python}\nimport numpy as np\n\nx = np.linspace(0,10,11)   \nprint( \"x = \" + str(x) )\n\n#   The above line constructs a vector that starts at 0, ends at 10, and\n#   has 11 entries (takes steps of size 1 from 0 to 10). Let\n\ny = np.sin(x)\nprint( \"y = \" + str(y) )\n```\n\n::: {.callout}\n**Q.** Looking at the values in 'y' printed above, can you tell what's happending?\n\n**A.** Not really ... let's visualize `y` vs `x` instead.\n:::\n\n#### matplotlib\nTo visualize `y` versus `x` let's plot it. To do so, let's first import some basic plotting routines from `matplotlib`, which provides a nice <a href=\"https://matplotlib.org/\" rel=\"external\">2D plotting library</a>. We'll also tell Python to show  `matplotlib` graphics inline, in this notebook.\n\nLet's start by plotting a simple example for `x` and `y`,\n\n```{pyodide-python}\nimport matplotlib.pyplot as plt\nx = ([1, 2, 3, 4])\ny = x\nplt.figure()\nplt.plot(x,y) \nplt.show()          # this is the plotting equivalent of print()\n```\n\n::: {.callout}\n**Q.** Does the plot above make sense for the variables `x` and `y`?\n:::\n\nNow, let's go back to the definitions of `x` and `y` that we started this example with and plot `y` versus `x`.\n\n```{pyodide-python}\nx = np.linspace(0,10,11)   \ny = np.sin(x)\n\nplt.figure()\nplt.plot(x, y)\nplt.show()\n```\n\n The plot of `x` versus `y` should look a bit jagged, and not \n smooth like a sinusoid.  To make the curve smoother,\n let's redefine `x` as,\n\n```{pyodide-python}\nimport numpy as np\nx = np.linspace(0,10, 101)\nprint(x)\n```\n\n::: {.callout}\n**Q.**  Compare this definition of `x` to the definition above.  How do these\ntwo definitions differ?\n:::\n\n::: {.callout}    \n**Q.**  What is the size of `x`?  Does this make sense?\n:::\n\nNow let's replot the sine function.\n\n```{pyodide-python}\ny = np.sin(x)\nplt.figure()\nplt.plot(x,y,'k')   # the 'k' we've added makes the curve black instead of blue\nplt.show()\n```\n\n::: {.callout}\n**Q.** Does this plot make sense, given your knowledge of `x`, `y`, and trigonometry?\n:::\n\n### Example 15: What if we want to compare several functions?\n\nContinuing the example in the previous section, let’s define a second vector\n\n```{pyodide-python}\nimport numpy as np\nx = np.linspace(0,10, 101)\nz = np.cos(x)\n```\n\nand plot it:\n\n```{pyodide-python}\nimport matplotlib.pyplot as plt\nplt.figure()\nplt.plot(x,z)\nplt.show()\n```\n\nWe’d now like to compare the two variables `y` and `z`. To do this, let’s plot both vectors on\nthe same figure, label the axes, and provide a legend,\n\n```{pyodide-python}\ny = np.sin(x)\nplt.figure()\nplt.plot(x,z)                     # plot z vs x.\nplt.plot(x,y,'r')                 # plot y vs x in red\nplt.show()\n```\n\nNotice that we’ve included a third input to the function `plot`. Here the third input tells Python to draw the curve in a particular color: `'r'` for red. There are many options we can use to plot; to see more, check out the documentation for <a href=\"https://matplotlib.org/api/_as_gen/matplotlib.pyplot.plot.html\" rel=\"external\">plot</a>.\n\nWe can also label the axes, give the figure a title, and provide a legend,\n\n```{pyodide-python}\nplt.figure()\nplt.plot(x,z)                     # plot z vs x\nplt.plot(x,y,'r')                 # plot y vs x in red\nplt.xlabel('x')                   # x-axis label\nplt.ylabel('y or z')              # y-axis label\nplt.title('y vs x and z vs x')    # title\nplt.legend(('y','z'))             # make a legend labeling each line\nplt.show()\n```\n\nTo futher edit this plot, you might decide - for example - that the font size for the labels is too small. We can change the default with:\n\n```{pyodide-python}\nplt.figure()\nplt.plot(x,y, label='y')     # sometimes it is easier to name a trace within the plot() call\nplt.plot(x,z, label='z')     # notice without a color matplotlib will assign one\nplt.xlabel('x', fontsize=14)\nplt.ylabel('y', fontsize=14)\nplt.title('y vs x', fontsize=18)\nplt.legend(fontsize=12)\nplt.show()\n```\n\n###  Example 16:  We can make random numbers in Python.\nTo generate a single Gaussian random number in Python, use the function in the NumPy `random` module.\n\n```{pyodide-python}\nimport numpy as np\n\nprint(\"a Gaussian random number (mean=0, variance=1): \" + str( np.random.randn() ))\n\n# a uniform random number on [0,1)\nprint(\"a uniform random number from [0,1): \" + str(np.random.rand()))\n```\n\nLet's generate a vector of 1000 Gaussian random numbers:\n\n```{pyodide-python}\nr = np.random.randn(1000)\n```\n\n... and look at a histogram of the vector:\n\n```{pyodide-python}\nimport matplotlib.pyplot as plt\nplt.figure()\nplt.hist(r)\nplt.show()\n```\n\n::: {.callout}\n**Q.** Does this histogram make sense? Is it what you expect for a distribution of Gaussian random variables?\n:::\n\n<div class=\"python-note\">\n    \nSee Python Help (`hist?`) to learn about the function `hist()`.\n\n</div>\n\n###  Example 17: Sampling randomly from a vector (courtsey of [vgascue](https://github.com/vgascue))\n\nUsing the random module from numpy one can also take a random sample from a vector. \nLet's take 5 random samples from the vector \"r\" generated in example 16.\n\n```{pyodide-python}\nimport numpy as np\nsample = np.random.choice(r, size=5)\nprint(\"5 random samples from vector r : \" + str(sample))\n```\n\nTry running it more the one time to see how the output changes!\n\n###  Example 18:  Repeating commands over and over and over . . . \n  Sometimes we'll want to repeat the same command over and over again.\n  For example, what if we want to plot `sin(x + k*pi/4)` where `k` varies from 1 to 5 in\n  steps of 1;  how do we do it?  Consider the following:\n\n```{pyodide-python}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.arange(0,10,0.1) # Define a vector x that ranges from 0 to 9.9 with step 0.1.\nk = 1                # Fix k=1,\ny = np.sin(x + k*np.pi/4)  # ... and define y at this k.\n\nplt.figure()               # Make a new figure,\nplt.plot(x,y)              # ... and plot y versus x.\n\nk = 2                # Let's repeat this, for k=2,\ny = np.sin(x + k*np.pi/4)  # ... and redefine y at this k,\nplt.plot(x,y)              # ... and plot it.\n\nk = 3                      # Let's repeat this, for k=3,\ny = np.sin(x + k*np.pi/4)  # ... and redefine y at this k,\nplt.plot(x,y)              # ... and plot it.\n\nk = 4                      # Let's repeat this, for k=4,\ny = np.sin(x + k*np.pi/4)  # ... and redefine y at this k,\nplt.plot(x,y)              # ... and plot it.\n\nk = 5                      # Let's repeat this, for k=5,\ny = np.sin(x + k*np.pi/4)  # ... and redefine y at this k,\nplt.plot(x,y)              # ... and plot it.\n\nplt.show()\n```\n\nThat's horrible code!  All I did was cut and paste the same thing four times.  As a general rule, if you're repeatedly cutting and pasting in code, what you're doing is inefficient and typically error prone.  There's a much more elegant way to do this, and it involves making a `for` loop.  Consider:\n\n```{pyodide-python}\nx = np.arange(0,10,0.1)     #First, define the vector x.\n```\n\nNow let's declare a `for` loop where `k` successively takes the values 1, then 2, then 3, ..., up to 5. Note, any code we want to execute as part of the loop must be indented one level. The first line of code that is not indented, in this case `show()` below, executes after the for loop completes\n\n```{pyodide-python}\nplt.figure()\nfor k in range(1,6):               \n    y = np.sin(x + k*np.pi/4) #Define y (note the variable 'k' in sin), also note we have indented here!\n    plt.plot(x,y)             #Plot y versus x\n     \n# no indentation now, so this code follows the loop\nplt.show()\n```\n\nThe small section of code above replaces all the cutting-and-pasting.\n  Instead of cutting and pasting, we update the definition of `y` with different values of `k` and plot it within this for-loop.\n\n::: {.callout}\n**Q.**  Spend some time studying this for-loop.  Does it make sense?\n:::\n\n::: {.callout-note}   \n**Important:** Python uses **indentation** to define `for` loops.\n:::\n\n###  Example 19:  Defining a new function.\nWe've spent some time in this notebook writing and executing code. Sometimes we'll need to write our own Python functions.  Let's do that now.\n\nOur function will do something very simple: it will take as input a\nvector and return as output the vector elements squared plus an additive\nconstant.\n\nIf have a vector, `v`, and a constant, `b`, we would like to call:\n\n    vsq = my_square_function(v, b)\n    \nThis won't work!  We first need to define `my_square_function`. Let's do so now,\n\n```{pyodide-python}\ndef my_square_function(x, c):\n    \"\"\"Square a vector and add a constant.\n\n    Arguments:\n    x -- vector to square\n    c -- constant to add to the square of x\n    \n    Returns:\n    x*x + c\n    \"\"\"\n    \n    return x * x + c\n```\n\nThe function begins with the keyword `def` followed by the function name and the inputs in parentheses. Notice that this first line ends with a colon `:`. All of the function components that follow this first line should be **indented one level**. This is just like the `for` loop we applied earlier; the operations performed by the for loop were indented one leve.\n\n<div class=\"python-note\">\n    \nWhen defining the function, the code the function executes should be indented one level.\n\n</div>\n\nThe text inside triple quotes provides an optional documentation string that describes our function. While optional, including a '*doc string*' is an important part of making your code understandable and reuseable.\n\nThe keyword `return` exits the function, and in this case returns the expression `x * x + c`. Note that a return statement with no arguments returns `None`, indicating the absence of a value.\n\nWith the function defined, let's now call it. To do so we first define the inputs, and then run the function, as follows:\n\n```{pyodide-python}\nimport numpy as np\nv = np.linspace(0.,10.,11)\nb = 2.5\n\n# Now let's run the code,\nv2 = my_square_function(v, b)\nprint(\"v = \" + str(v))\nprint(\"v*v+2.5 = \" + str(v2))\n```\n\n::: {.callout}\n**Q.** Try to make a function, my_power, so that \n`y = power(x,n)` evaluates $y = x^n$, \n(in Python you can use `x**n` to take the power)\n:::\n\n### Example 20: Load  data into Python\nFor our last example let's load a data file on the web in the `.csv` format into Python.\n\nTo do so, let's first import the `pandas` module,\n\n```{pyodide-python}\nimport pandas as pd\n```\n\nNow, let's load a data file using the function `read_csv`,\n\n```{pyodide-python}\ndf = pd.read_csv(\"https://raw.githubusercontent.com/Mark-Kramer/BU-MA665-MA666/master/Data/Rhythms_1.csv\")\ndf.info()\n```\n\nThe variable `df` that holds the loaded data is a Python [DataFrame](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html). We can think of it as a simple table that holds our data.\n\nLet's print it,\n\n```{pyodide-python}\nprint(df)\n```\n\nWe see that the columns in the dataframe consist of two variables: `d` and `t`. Our collaborator who provided the data tells us that these correspond to the voltage recording (`d`) and a time axis (`t`) for her data.\n\nLet's define variables to hold the data corresponding to each key,\n\n```{pyodide-python}\nimport numpy as np\nd = np.array(df.iloc[:,0])  #Get the values associated with the first column of the dataframe\nt = np.array(df.iloc[:,1])  #Get the values associated with the first column of the dataframe\n```\n\n::: {.callout-note}\nHere we convert the data in each column to a numpy array, because we'd (probably) like numpy to function on these values.\n:::\n\nNow, let's plot the LFP data versus the time axis,\n\n```{pyodide-python}\nimport matplotlib.pyplot as plt\n\n# Choose a subset to plot\nt = t[0:500]\nd = d[0:500]\n\nplt.figure()\nplt.plot(t, d)\nplt.title('My plot')\nplt.xlabel('Time [s]')\nplt.ylabel('Voltage [mV]')\nplt.show()\n```\n\n### Example 21: Compute statistics and compare (courtesy of [mateouma](https://github.com/mateouma))\n\n\nLet's do some statistics. First, our standard imports.\n\n```{pyodide-python}\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n```\n\nWith numpy, we can find the mean and standard deviation of our LFP data.\n\n```{pyodide-python}\nmu = np.mean(d)\nsd = np.std(d)\n```\n\nNow, let's use numpy to randomly generate numbers according to a normal distribution with the same mean and standard deviation as the LFP data. The syntax is `np.random.normal(mean, sd, size)`, where `mean`, `sd`, and `size` are variables or numbers.\n\n```{pyodide-python}\nsamps = np.random.normal(mu, sd, 500)\n```\n\nWe can use a histogram to compare the distribution of the data with a normal distribution with the same mean and standard deviation.\n\n```{pyodide-python}\nplt.figure()\nplt.hist(samps)\nplt.hist(d)\nplt.show()\n```\n\nAs we can see, our data doesn't look normally distributed, but in practice we should use a statistical test to make this assessment.\n\n### Example 22: Recursion (courtsey of [marieshi](https://github.com/marieshi))\n\nLet's consider a classic mathematical sequence: the [Fibonacci sequence](https://en.wikipedia.org/wiki/Fibonacci_sequence). This is a sequence that starts with 0 and 1, and each number is the sum of the preceding two numbers in the sequence.\n\nLet's use this sequence to expand our knowledge of functions.\n\nWe use recursive functions when we want to call the function itself within the function.\n\n```{pyodide-python}\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n```\n\n```{pyodide-python}\n\ndef Fib(n):\n    #First establish base cases, or cases that are pre-defined by the question.\n    if n<= 0:\n        print(\"Incorrect input\")\n    # First Fibonacci number is 0\n    elif n == 1:\n        return 0\n    # Second Fibonacci number is 1\n    elif n == 2:\n        return 1\n    else:\n        return Fib(n-1)+Fib(n-2)\n```\n\n```{pyodide-python}\nFib(20)\n```\n\nWe can think of recursive functions algorithmically: it usually starts with one or more base cases, or the simplest form of the function. This defines the behavior and serve as an anchor. \n\nNext are the recursive calls, which simplifies the problem iteratively, usually by calling the function back onto itself.\n\n::: {.callout}\n**Q.** What is the difference between using recursion and loops in this case? Do you see any benefits? \n:::\n\nRecursion tends to be most functional when analyzing tree or nested structures.\n\nFor example, if you are writing code and have a lot of parantheses you can't keep track of, we can use recursion to see if they are balanced.\n\nTo keep this a bit simpler, let's pretend that you have extracted all the parantheses and just need to check if a string of open or closed parantheses are balanced.\n\nFor example, () is balanced, )))((( or (() are not. \n\n```{pyodide-python}\ndef is_balanced(s):\n    # If string is empty, it's balanced\n    if not s:\n        return True\n    \n    # If the first character is a closing parenthesis, it's unbalanced\n    if s[0] == ')':\n        return False\n    \n    # Recursive step: Find the matching closing parenthesis for the first opening parenthesis\n    else:\n        balance = 0\n        # If the parentheses are balanced, there should be equal closing and opening parantheses. This will be represented by balance=0\n        for i in range(len(s)):\n            if s[i] == '(':\n                balance += 1\n            elif s[i] == ')':\n                balance -= 1\n            \n            if balance == 0:\n                # Recursively check the substring inside the matched pair\n                # and the substring after the matched pair\n                return is_balanced(s[1:i]) and is_balanced(s[i+1:])\n        \n        # if balance !=0, not balanced.\n        return False\n    \n```\n\nLet's test our function out!\n\n```{pyodide-python}\nprint(is_balanced(\"(()())\")) \n```\n\n```{pyodide-python}\nprint(is_balanced(\"())\"))\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"ignore":["Dont-Sync-2024"]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"number-sections":false,"filters":["pyodide"],"output-file":"Introduction.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","theme":"cosmo","title":"Introduction to Python for the practicing neuroscientist","jupyter":"python 3"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
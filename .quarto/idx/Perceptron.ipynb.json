{"title":"Perceptron","markdown":{"yaml":{"title":"Perceptron","project":{"type":"website"},"format":{"html":{"code-fold":true,"code-tools":true}},"jupyter":"python 3","number-sections":true,"filters":["pyodide"]},"headingText":"Preliminaries","containsRefs":false,"markdown":"\n\nIn this notebook, we will construct simple perceptron models. We'll start by implementing a perceptron model, and seeing how it behaves. We'll then outline the steps to train a perceptron to classify a point as above or below a line.\n\nThis discussion follows the excellent example and discussion at [The Nature of Code](https://natureofcode.com/book/chapter-10-neural-networks/). Please see that reference for additional details, and a more sophisticated coding strategy (using Classes in Python).\n\n\nBefore beginning, let's load in the Python packages we'll need:\n\n```{pyodide-python}\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\n```\n\n# A simple perceptron model\n\n \nLet's examine a simple perceptron that accepts inputs, processes those inputs, and returns an output. To do so, please complete this function:\n\n```{pyodide-python}\ndef my_perceptron(input1, input2, w1, w2, theta):\n    print(\"Do something!\")\n    # Define the activity of the perceptron, x. \n    # Apply a binary threshold.\n```\n\n```{pyodide-python}\nmy_perceptron(1,0,0.5,-0.5,0)\n```\n\n::: {.callout}\n**Q:** How many inputs does the function take?  How many outputs does it return?\n:::\n\n::: {.callout}\n**Q:** Apply this function to different sets of inputs. Consider,<p></p>\n\n  `input1 = 1, input2 = 0, w1 = 0.5, w2 = -0.5, theta = 0`<p></p>\n\n  and<p></p>\n\n  `input1 = 1, input2 = 0, w1 = 0.5, w2 = -0.5, theta = -1`<p></p>\n\n  What do you find?\n:::\n\n# Build a perceptron classifier\n\nWe'd like to create a method to train a perceptron to classify a point (x,y) as above or below a line. Let's implement this training procedure.\n\n##  Provide perceptron with inputs and known answer. \n\n  First, let's make a function that computes a line, and determines if \n  a given `y` value is above or below the line. We'll use this function\n  to return the correct (\"known\") answer. Having known answers is\n  important for training the perceptron. We'll use the known answers to\n  tell the when it's right or wrong (i.e., when the perceptron makes an\n  error).\n\n  Let's define the function (`known_answer`) should take four inputs:\n\n  - `slope`\n  - `intercept`\n  - `x`\n  - `y`\n\nwhere the (x,y) value is a point we choose on the plane. The function\n  should return one output:\n\n - `desired_output`\n\nwhere,\n\n`desired_output = 1`, if the `y` value (the last input) is above the line,\n\n`desired_putput = 0`, if the `y` value (the last input) is below the line.\n\nComplete the function below:\n\n```{pyodide-python}\ndef known_answer(slope, intercept, x, y):\n    print(\"Do something!\")\n    #Determine yline\n    #Determine if y is above yline\n```\n\n::: {.callout}\n**Q:** Consider the (x,y) point,<p></p>\n\n`x,y = 0.7,3` <p></p>\n\nand the line with slope and intercept, <p></p>\n\n`slope = 2` <br></br>\n`intercept = 1`<p></p>\n\nIs the (x,y) point above or below the line?\n:::\n\n**A:** To answer this, let's ask our function,\n\n```{pyodide-python}\nx,y       = 0.7,3\nslope     = 2\nintercept = 1\ncorrect_answer = known_answer(slope, intercept, x, y)\nprint(correct_answer)\n```\n\n**A (Continued):** We find a `correct_answer` of 1.<p></p>\n\nSo, the point `(x,y)=(0.7,3)` is above the line with slope 2 and intercept 1.\n\n## Ask perceptron to guess an answer.\n\n Our next step is to compare our desired output (computed in Step 1) to\n the output guessed by the perceptron. To do so, we'll need to compute\n the *feedforward* solution for the perceptron (i.e., given the inputs\n and bias, determine the perceptron output). Let's do so complete the function below,\n\n```{pyodide-python}\ndef feedforward(x, y, wx, wy, wb):\n    print(\"Do something!\")\n    # Fix the bias.\n    # Define the activity of the neuron, activity.\n    # Apply the binary threshold.\n```\n\nThis function takes five inputs:\n\n - `x`  = the x coordinate of the point we choose in the plane.\n - `y`  = the y coordinate of the point we choose in the plane.\n - `wx` = the weight of x input.\n - `wy` = the weight of y input.\n - `wb` = the weight of the bias.\n\nAnd this function returns one output:\n \n - the perceptron's guess, is the point above (=1) or below (=0) the line.\n\n::: {.callout}\n**Q:**  Again consider the (x,y) point, <p></p>\n\n`x,y = 0.7,3` <p></p>\n\nand set initial values for the perceptron weights. Let's just set these all to 0.5;  our goal in the rest of this module will be to train the perceptron by adjusting these weights.  But for now,<p></p>\n\n`wx,wy,wb = 0.5` <p></p>\n\nThen, ask the perceptron for it's guess for it's guess, is the point above or below the line?<p></p>\n\n:::\n\n```{pyodide-python}\nx,y      = 0.7,3\nwx,wy,wb = 3*[0.5]\nperceptron_guess = feedforward(x, y, wx, wy, wb)\nprint(perceptron_guess)\n```\n\n**A:** We find a `peceptron_guess` of 1.<br>\n\nSo, the perceptron guesses that the point `(x,y)=(0.7,3)` is above the line.\n\n## Compute the error.\n\n We've now answered the question \"*Is the (x,y) point above the line?*\" in \n two ways:\n \n - the known answer, and \n - the perceptron's guess.\n\nLet's compute the error as the difference between these two answers:\n\n```{pyodide-python}\nerror = 'SOMETHING?'\nprint(error)\n```\n\n::: {.callout}\n**Q:** What do you find for the `error`? Does it make sense?\n:::\n\n## Adjust all weights according to the error.\n\n To update the weights, we'll use the expression,\n\n `new weight = weight + error * input * learning constant`\n\n We need to compute this for each weight `(wx, wy, wb)`.\n\n First, let's set the learning constant,\n\n```{pyodide-python}\nlearning_constant = 0.01\n```\n\nThen, we can compute the new weights,\n\n```{pyodide-python}\nwx = \"SOMETHING\"\nwy = \"SOMETHING\"\nwb = \"SOMETHING\"\nprint(wx)\n```\n\nNotice that, in the update to `wb` we use the fact that the bias equals 1.\n\n::: {.callout}\n**Q:**  What do you find for the new weights? Does it make sense?\n:::\n\n## Return to Step 1 and repeat ... \n We could try to compute these repetitions by hand, for example by repeating\n the cells above. To do so, we'd choose a new point in the (x,y) plane,\n determine whether it's above the line 2x+1, ask the perceptron to guess\n whether it's above the line, then use the error to update the\n perceptron's weights. \n\n But we want to evaluate this procedure 2000 times. Doing so by\n hand would be a total pain, and highly error prone. Instead, let's\n ask the computer to do the boring work of multiple repetitions. To do so,\n let's collect the code above, and examine 2000 (x,y) points chosen\n randomly in the plane. We'll wrap our code above inside a for-loop to\n make this efficient,\n\n```{pyodide-python}\nslope     = 2;                      # Define the line with slope, \nintercept = 1;                      # ... and intercept.\n\nwx,wy,wb = 3*[0.5];                 # Choose initial values for the perceptron's weights\n\nlearning_constant = 0.01;           # And, set the learning constant.\n\nestimated_slope = np.zeros(2000)    # Variables to hold the perceptron estimates.\nestimated_intercept = np.zeros(2000)\n\nfor k in np.arange(2000):           # For 2000 iteractions,\n    x = np.random.randn(1);         # Choose a random (x,y) point in the plane\n    y = np.random.randn(1);\n                                    # Step 1: Calculate known answer.\n    \n                                    # Step 2. Ask perceptron to guess an answer.\n    \n                                    # Step 3. Compute the error.\n    \n                                    # Step 4. Adjust weights according to error.\n     \n    estimated_slope[k] = -wx/wy;    # Compute estimated slope from perceptron.\n    estimated_intercept[k] = -wb/wy;# Compute estimated intercept from perceptron.\n\n# Display the results! ------------------------------------------------------------------------\nx_range = np.linspace(-2,2,100);                  # For a range of x-values,\nfig, ax = plt.subplots()\nax.plot(x_range, slope*x_range+intercept, 'k')    # ... plot the true line,\n\nfor k in range(1,2000,100):                       # ... and plot some intermediate perceptron guess\n     ax.plot(x_range, estimated_slope[k]*x_range+estimated_intercept[k], 'r', alpha=0.25)\n                                                  # ... and plot the last perceptron guess\nplt.xlabel('x')\nplt.title('Known answer (black), Perceptron final guess (blue)')\nplt.show()\n```\n","srcMarkdownNoYaml":"\n\nIn this notebook, we will construct simple perceptron models. We'll start by implementing a perceptron model, and seeing how it behaves. We'll then outline the steps to train a perceptron to classify a point as above or below a line.\n\nThis discussion follows the excellent example and discussion at [The Nature of Code](https://natureofcode.com/book/chapter-10-neural-networks/). Please see that reference for additional details, and a more sophisticated coding strategy (using Classes in Python).\n\n\n#  Preliminaries\nBefore beginning, let's load in the Python packages we'll need:\n\n```{pyodide-python}\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\n```\n\n# A simple perceptron model\n\n \nLet's examine a simple perceptron that accepts inputs, processes those inputs, and returns an output. To do so, please complete this function:\n\n```{pyodide-python}\ndef my_perceptron(input1, input2, w1, w2, theta):\n    print(\"Do something!\")\n    # Define the activity of the perceptron, x. \n    # Apply a binary threshold.\n```\n\n```{pyodide-python}\nmy_perceptron(1,0,0.5,-0.5,0)\n```\n\n::: {.callout}\n**Q:** How many inputs does the function take?  How many outputs does it return?\n:::\n\n::: {.callout}\n**Q:** Apply this function to different sets of inputs. Consider,<p></p>\n\n  `input1 = 1, input2 = 0, w1 = 0.5, w2 = -0.5, theta = 0`<p></p>\n\n  and<p></p>\n\n  `input1 = 1, input2 = 0, w1 = 0.5, w2 = -0.5, theta = -1`<p></p>\n\n  What do you find?\n:::\n\n# Build a perceptron classifier\n\nWe'd like to create a method to train a perceptron to classify a point (x,y) as above or below a line. Let's implement this training procedure.\n\n##  Provide perceptron with inputs and known answer. \n\n  First, let's make a function that computes a line, and determines if \n  a given `y` value is above or below the line. We'll use this function\n  to return the correct (\"known\") answer. Having known answers is\n  important for training the perceptron. We'll use the known answers to\n  tell the when it's right or wrong (i.e., when the perceptron makes an\n  error).\n\n  Let's define the function (`known_answer`) should take four inputs:\n\n  - `slope`\n  - `intercept`\n  - `x`\n  - `y`\n\nwhere the (x,y) value is a point we choose on the plane. The function\n  should return one output:\n\n - `desired_output`\n\nwhere,\n\n`desired_output = 1`, if the `y` value (the last input) is above the line,\n\n`desired_putput = 0`, if the `y` value (the last input) is below the line.\n\nComplete the function below:\n\n```{pyodide-python}\ndef known_answer(slope, intercept, x, y):\n    print(\"Do something!\")\n    #Determine yline\n    #Determine if y is above yline\n```\n\n::: {.callout}\n**Q:** Consider the (x,y) point,<p></p>\n\n`x,y = 0.7,3` <p></p>\n\nand the line with slope and intercept, <p></p>\n\n`slope = 2` <br></br>\n`intercept = 1`<p></p>\n\nIs the (x,y) point above or below the line?\n:::\n\n**A:** To answer this, let's ask our function,\n\n```{pyodide-python}\nx,y       = 0.7,3\nslope     = 2\nintercept = 1\ncorrect_answer = known_answer(slope, intercept, x, y)\nprint(correct_answer)\n```\n\n**A (Continued):** We find a `correct_answer` of 1.<p></p>\n\nSo, the point `(x,y)=(0.7,3)` is above the line with slope 2 and intercept 1.\n\n## Ask perceptron to guess an answer.\n\n Our next step is to compare our desired output (computed in Step 1) to\n the output guessed by the perceptron. To do so, we'll need to compute\n the *feedforward* solution for the perceptron (i.e., given the inputs\n and bias, determine the perceptron output). Let's do so complete the function below,\n\n```{pyodide-python}\ndef feedforward(x, y, wx, wy, wb):\n    print(\"Do something!\")\n    # Fix the bias.\n    # Define the activity of the neuron, activity.\n    # Apply the binary threshold.\n```\n\nThis function takes five inputs:\n\n - `x`  = the x coordinate of the point we choose in the plane.\n - `y`  = the y coordinate of the point we choose in the plane.\n - `wx` = the weight of x input.\n - `wy` = the weight of y input.\n - `wb` = the weight of the bias.\n\nAnd this function returns one output:\n \n - the perceptron's guess, is the point above (=1) or below (=0) the line.\n\n::: {.callout}\n**Q:**  Again consider the (x,y) point, <p></p>\n\n`x,y = 0.7,3` <p></p>\n\nand set initial values for the perceptron weights. Let's just set these all to 0.5;  our goal in the rest of this module will be to train the perceptron by adjusting these weights.  But for now,<p></p>\n\n`wx,wy,wb = 0.5` <p></p>\n\nThen, ask the perceptron for it's guess for it's guess, is the point above or below the line?<p></p>\n\n:::\n\n```{pyodide-python}\nx,y      = 0.7,3\nwx,wy,wb = 3*[0.5]\nperceptron_guess = feedforward(x, y, wx, wy, wb)\nprint(perceptron_guess)\n```\n\n**A:** We find a `peceptron_guess` of 1.<br>\n\nSo, the perceptron guesses that the point `(x,y)=(0.7,3)` is above the line.\n\n## Compute the error.\n\n We've now answered the question \"*Is the (x,y) point above the line?*\" in \n two ways:\n \n - the known answer, and \n - the perceptron's guess.\n\nLet's compute the error as the difference between these two answers:\n\n```{pyodide-python}\nerror = 'SOMETHING?'\nprint(error)\n```\n\n::: {.callout}\n**Q:** What do you find for the `error`? Does it make sense?\n:::\n\n## Adjust all weights according to the error.\n\n To update the weights, we'll use the expression,\n\n `new weight = weight + error * input * learning constant`\n\n We need to compute this for each weight `(wx, wy, wb)`.\n\n First, let's set the learning constant,\n\n```{pyodide-python}\nlearning_constant = 0.01\n```\n\nThen, we can compute the new weights,\n\n```{pyodide-python}\nwx = \"SOMETHING\"\nwy = \"SOMETHING\"\nwb = \"SOMETHING\"\nprint(wx)\n```\n\nNotice that, in the update to `wb` we use the fact that the bias equals 1.\n\n::: {.callout}\n**Q:**  What do you find for the new weights? Does it make sense?\n:::\n\n## Return to Step 1 and repeat ... \n We could try to compute these repetitions by hand, for example by repeating\n the cells above. To do so, we'd choose a new point in the (x,y) plane,\n determine whether it's above the line 2x+1, ask the perceptron to guess\n whether it's above the line, then use the error to update the\n perceptron's weights. \n\n But we want to evaluate this procedure 2000 times. Doing so by\n hand would be a total pain, and highly error prone. Instead, let's\n ask the computer to do the boring work of multiple repetitions. To do so,\n let's collect the code above, and examine 2000 (x,y) points chosen\n randomly in the plane. We'll wrap our code above inside a for-loop to\n make this efficient,\n\n```{pyodide-python}\nslope     = 2;                      # Define the line with slope, \nintercept = 1;                      # ... and intercept.\n\nwx,wy,wb = 3*[0.5];                 # Choose initial values for the perceptron's weights\n\nlearning_constant = 0.01;           # And, set the learning constant.\n\nestimated_slope = np.zeros(2000)    # Variables to hold the perceptron estimates.\nestimated_intercept = np.zeros(2000)\n\nfor k in np.arange(2000):           # For 2000 iteractions,\n    x = np.random.randn(1);         # Choose a random (x,y) point in the plane\n    y = np.random.randn(1);\n                                    # Step 1: Calculate known answer.\n    \n                                    # Step 2. Ask perceptron to guess an answer.\n    \n                                    # Step 3. Compute the error.\n    \n                                    # Step 4. Adjust weights according to error.\n     \n    estimated_slope[k] = -wx/wy;    # Compute estimated slope from perceptron.\n    estimated_intercept[k] = -wb/wy;# Compute estimated intercept from perceptron.\n\n# Display the results! ------------------------------------------------------------------------\nx_range = np.linspace(-2,2,100);                  # For a range of x-values,\nfig, ax = plt.subplots()\nax.plot(x_range, slope*x_range+intercept, 'k')    # ... plot the true line,\n\nfor k in range(1,2000,100):                       # ... and plot some intermediate perceptron guess\n     ax.plot(x_range, estimated_slope[k]*x_range+estimated_intercept[k], 'r', alpha=0.25)\n                                                  # ... and plot the last perceptron guess\nplt.xlabel('x')\nplt.title('Known answer (black), Perceptron final guess (blue)')\nplt.show()\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"ignore":["Dont-Sync-2024"]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"number-sections":true,"filters":["pyodide"],"output-file":"Perceptron.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","theme":"cosmo","title":"Perceptron","jupyter":"python 3"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}